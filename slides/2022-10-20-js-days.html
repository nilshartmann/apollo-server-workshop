<html lang="de">
  <!DOCTYPE html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>GraphQL APIs bauen</title>

    <link rel="stylesheet" href="revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="revealjs/styles.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-state="title">
          <h4 style="margin-bottom: 3rem; font-size: 3rem">
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>
          <h2 class="title" style="font-size: 7rem">
            <b>GraphQL APIs bauen</b>
          </h2>
          <h3 class="title" style="font-size: 5rem">
            <b>Ein praktischer Einstieg mit Apollo Server</b>
          </h3>
          <h3 class="title" style="font-size: 3rem; margin-bottom: 3rem">
            <b>JavaScript Days, 20. Oktober 2022</b>
          </h3>

          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Slides (online)</span></h3>
            <p>
              <a class="Link" href="https://graphql.schule/jsdays2022"
                >https://graphql.schule/jsdays2022</a
              >
            </p>
          </div>
          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Workspace Installation</span></h3>
            <p>
              <a
                class="Link"
                href="https://github.com/nilshartmann/spring-graphql-training/blob/main/INSTALL.md"
                >https://graphql.schule/jsdays-2022-install</a
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!--        <section>-->
        <!--          <h2>Und ihr?</h2>-->
        <!--          <ul>-->
        <!--            <li>Stellt euch doch bitte kurz vor...</li>-->
        <!--            <li>-->
        <!--              Eure Vorkenntnisse in <b>GraphQL</b>, <b>Java</b>, <b>Spring?</b>,-->
        <!--              <b>React/TypeScript</b>-->
        <!--            </li>-->
        <!--            <li>-->
        <!--              W√ºnsche f√ºr diese Schulung? Besondere Themen oder Interessen?-->
        <!--            </li>-->
        <!--          </ul>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>

## Kurze Vorstellung

* Mentimeter Umfrage:
  * Was ist Eure bisherige GraphQL Erfahrung?
  * Was verwendet ihr normalerweise an Technologie?
  * Link im Chat

---

## Agenda

* Teil 1: GraphQL
  * Was ist GraphQL?
  * [Die Abfragesprache](#/graphql-sprache)

* Teil 2: [GraphQL APIs bereitstellen](#/graphql-apis-bereitstellen)
  * [Das Schema Definieren](#/schema)
  * [Die Basis: graphql-java](#/graphql-java)
  * [Exkurs: Einf√ºhrung in Spring und Spring Boot](#/exkurs-spring)
  * [GraphQL APIs mit Spring for GraphQL](#/spring-for-graphql)

* Teil 3: [GraphQL Clients mit React und Apollo](#/t-apollo-react)

---

## Zeitplan

* 09:00 bis 12:30 Teil 1
* 12:30 bis 13:30 Mittag üçï üçù
* 13:30 bis 17:00 Teil 2
* Zwischendurch Pausen ‚òïÔ∏è üç∞

---


## Grunds√§tzliches

* **Jederzeit:** Fragen und Diskussionen! Bringt Euch gerne ein!
* Motto: Es gibt keine dummen Fragen!
* Ich zeige viel direkt im Editor, aber ihr k√∂nnt die Slides als Referenz benutzen

---

# GraphQL


_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---

# GraphQL


_"GraphQL is a **query language for APIs** and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a **runtime for fulfilling** those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with **your existing data**"_ ([https://graphql.org](https://graphql.org))

---

## Spezifikation

* https://spec.graphql.org/
* Umfasst:
  * Query Sprache und -Ausf√ºhrung
  * Schema Definition Language
* Kein fertiges Produkt, keine fertige Bibliothek
   * Es gibt Bibliotheken, die dir helfen, GraphQL APIs zu implementieren und bereitzustellen
   * Die abgefragten Daten m√ºssen wir selbst ermitteln
   * GraphQL macht keine Aussage dar√ºber, wo diese Daten herkommen (Datenbank, Micro-Service, Berechnung ...)

---

## Die Beispiel-Anwendung

<img style="border: 1px solid grey" src="images/publy-screenshot.png" />

[http://localhost:3000](http://localhost:3000)

---

## Beispiel: GraphiQL

<img style="border: 1px solid grey" src="images/screenshot-graphiql.png" />

[http://localhost:8080](http://localhost:8080)

---


## Beispiel: GraphQL Tooling

* <!-- .element: class="demo" --> IntelliJ IDEA
  * <!-- .element: class="demo" --> graphql-Extension (hello.graphql)
  * <!-- .element: class="demo" --> GraphQL.md im publy-Verzeichnis
  * <!-- .element: class="demo" --> language=GraphQL in einer leeren Java-Datei

* <!-- .element: class="demo" --> TypeScript (optional)
  * <!-- .element: class="demo" --> publy-frontend, npm run codegen:watch
  * <!-- .element: class="demo" --> StoryPage.query.graphql zeigen und story-Feld entfernen
---

<!-- .slide: id="graphql-sprache" -->
# Die GraphQL Abfrage-Sprache
---

### Sprache, um **Felder** aus einem **Objekt-Graphen** abzufragen

```graphql
  query {
    story {
      id title writtenBy {
        id user { name }
      }
    }
  }

---

### Felder k√∂nnen **Argumente** haben

<pre><code class="graphql">
  query {
    story(storyId: 5) {
      id title writtenBy {
        id user { name }
      }
    }
  }
</code></pre>

---

### Die **Antwort** sieht immer so aus, wie die Abfrage

<img src="images/query-antwort.png" />

---

### Operation-Type

Ausgef√ºhrt werden **Operationen**.
Der **Operation-Type** beschreibt, was in der Anfrage getan werden soll

* **query**: Daten lesen (Default-Operation, Schl√ºsselwort "query" kann weggelassen werden)
* **mutation**: Daten ver√§ndern
* **subscription**: Daten vom Server bekommen, sobald sie erzeugt wurden (√§hnlich wie Events)

---


### Operation-Type

Der Operation-Type bestimmt auch den Einstiegspunkt in den Objekt-Graphen

<img src="images/einstiegspunkte.png" />

---

### Namen von Operationen

* Operationen k√∂nnen **Namen** haben.
* Das ist vor allem f√ºr Debugging und Code-Generatoren relevant

* ```graphql
  query NewestStory {
      story {
        id
        title
      }
  }
  ```

---

### Fragmente

* Mit einem **Fragment** beschreibst Du eine wiederverwendbare Menge von Feldern
* ```graphql
  fragment BaseMember on Member {
      id joined
      user { is username }
  }

  query {
      story {
        writtenBy { ...BaseMember }

        comments {
          givenBy { ...BaseMember }
        }
      }
  }
  ```


---

### Variablen

* Queries k√∂nnen **Variablen** haben.
* Variablen m√ºssen im Query deklariert werden
* Werte f√ºr Variablen werden in einem eigenen JSON-Objekt an den Server geschickt

* ```graphql
  query ($storyId: ID!) {
    story(id: $storyId) {
      id
      title body
    }
  }
  ```

---

## √úbung: Einen Query ausf√ºhren

_Mach' dich mit der GraphQL-Abfragesprache vertraut_

* √ñffne GraphiQL auf meinem Computer (URL gebe ich euch)
* Versuche einen Query auszuf√ºhren, der die ersten vier Stories zur√ºckliefert und folgende Felder abfragt:
  * Id, Titel, Excerpt, Ver√∂ffentlichungsdatum, Wer hat die Story geschrieben und die jeweils ersten zehn Kommentare
  * Kannst Du den Query so erweitern, dass er die ersten zehn _neusten_ Stories zur√ºckliefert?
* Bau eine Fragment (`Author`), das aus dem `Member` dessen Id, sowie `fullname` und `id` des Users enth√§lt
  * Verwende das Fragment, um in den Stories und den Kommentaren jeweils die Member-Informationen abzufragen
  * In den Stories zus√§tzlich noch `skills` des Members abfragen
* Du kannst Code-Completion und den `Docs`-Explorer (rechts oben) verwenden, um die API zu untersuchen
* M√∂gliche L√∂sungen findest Du auf den folgenden Slides.

---
## L√∂sung: vier Stories mit Kommentaren

```graphql
query($page: Int!, $pageSize: Int!) {
  stories(page: $page,pageSize: $pageSize) {
    stories {

      id
      title
      excerpt
      createdAt
      writtenBy {
        user {
          fullname
        }
      }
      comments {
          id
          content
        }
      }
    }
  }
}
```
```json
{
  "pageSize": 4,
  "page": 0
}
```
---
## L√∂sung mit Sortierkriterium
```graphql
query($page: Int!, $pageSize: Int!, $sortBy: StorySortCriteria) {
  stories(page: $page,pageSize: $pageSize, sortBy: $sortBy) {
    stories {

      id
      title
      excerpt
      createdAt
      writtenBy {
        user {
          fullname
        }
      }
      comments {
          id
          content
        }
      }
    }
  }
}
```
```json
{
  "page": 0,
  "pageSize": 4,
  "sortBy": {
    "field": "date",
    "direction": "desc"
  }
}
```
---
## L√∂sung mit Fragment
```graphql
fragment Author on Member {
  id user { fullname id }
}

query($pageSize: Int!, $sortBy: StorySortCriteria) {
  stories(pageSize: $pageSize, sortBy: $sortBy) {
    stories {
      id
      title
      excerpt
      createdAt
      writtenBy {
        ...Author
        skills
      }
      comments {
          id
          content

          writtenBy { ...Author }
        }
      }
    }
  }
}
```
```json
{
  "sortBy": {
    "direction": "desc",
    "field": "date"
  },
  "pageSize": 4
}
```

---

### GraphQL Requests

* <!-- .element: class="demo" --> HTTP Request an die GraphQL API
  * <!-- .element: class="demo" --> request.http im publy-Ordner
  * <!-- .element: class="demo" --> Fehler zeigen
---

## GraphQL Requests

* √úblicherweise nur HTTP POST-Request
  * andere HTTP Verben spielen keine Rolle
  * HTTP Status-Code meist 200 OK, auch im Fehlerfall!
  * Gro√üer Unterscheid zu REST APIs
* Antwort-JSON-Objekt besteht aus maximal drei Feldern:
  * `data`: Die gelesenen Daten (Struktur darunter entspricht der Abfrage)
  * `errors`: Liste mit (technischen) Fehlern, u.a. Fehlermeldung
  * `extensions`: Freibelegbares Objekt f√ºr propriet√§re Erweiterungen (z.B. Debug-Informationen)

---

### Union-Typen

Ein **Union-Type** kann mehr als einen Typ zur√ºckliefern:

```graphql
  mutation  addComment
      (input: { storyId: "1", content: "..." }) {

      ...on AddCommentSuccessPayload {
        newComment { id }
      }

      ...on AddCommentFailurePayload {
        errorMessage
      }
  }
```

---
### Interfaces

* Ein Interface erzwingt gemeinsame Felder an den Objekten, die das Interface implementieren (√§hnlich
    wie in Java mit Methoden)

* Beispiel: `id` und `createdAt` sind am `Node`-Interface definiert

* ```graphql
  query {
      node(id: "...") {

        id
        createdAt

        ...on Story { title body }
        ...on Comment { content }
      }
  }
  ```

---
### Mutations und Subscriptions

* Mutations und Subscriptions sind syntaktisch wie Queries
* Bei einer Mutation werden Daten auf dem Server ver√§ndert
* Bei einer Subscription werden Daten vom Server auf den Client geschickt (Events)
---

## √úbung: Mutations
* F√ºhre eine Mutation aus, die einen neuen Kommentar erzeugt
* Du musst dazu im Playground im `Headers`-Tab den Header `X-Authorization` setzen, z.B. auf `U3`
* <img src="images/auth-header.png" height="400px" />
* Frage aus der Antwort im Erfolgsfall die Id des neuen Kommentars, sowie dessen Story und deren Kommentare ab (in der Liste sollte dein neuer Kommentar nun enthalten sein)
* Im Fehlerfall frage das `errorMsg`-Feld ab
* M√∂gliche L√∂sung auf der n√§chsten Slide
---
## L√∂sung: Mutation
```graphql
mutation($input: AddCommentInput!) {
  addComment(input: $input) {
    ...on AddCommentSuccessPayload {
      newComment {
        id
         story {
           title
           comments {
             id
             content
           }
         }
      }
    }
    ...on AddCommentFailedPayload {
      errorMsg
    }
  }
}
```
```json
{
  "input": {
    "content": "Neuer Kommentar",
    "storyId": "7"
  }
}
```
---
### Teil II
<!-- .slide: id="graphql-apis-bereitstellen" -->
# GraphQL APIs bereitstellen

---
<!-- .slide: id="schema" -->
### Das GraphQL Schema

* GraphQL APIs m√ºssen in einem Schema beschrieben werden.
* In dem Schema werden Objekte (Typen) mit Feldern beschrieben.
* Das Schema selbst ist zur Laufzeit mit einem _Introspection Query_ abfragbar
  * üßë‚Äçüíª Beispiel im Playground
* Mit der [Schema Definition Language](https://graphql.org/learn/schema/)

---

### Die SDL

* <!-- .element: class="demo" --> Demo: Schema-Definition 
  * <!-- .element: class="demo" --> ping-Feld mit Message Object
  * <!-- .element: class="demo" --> Argument!
  * <!-- .element: class="demo" --> R√ºckgabewert-String
  * <!-- .element: class="demo" --> Doku

---

### Die SDL

Beschreibung eines *Objekt Types*

<pre><code class="graphql">
  type Story {
    id: ID!

    title: String!
    body: String!
  }
</code></pre>

* Beschrieben werden **Felder** mit **Return Types**
* Ein Ausrufezeichen zeigt an, dass das Feld nicht _nullable_ ist

---

### Dokumentation und Kommentare

* Dokumentation mit drei doppelten Anf√ºhrungszeichen
  * Markdown zur Formatierung erlaubt
* Kommentare mit Hash-Zeichen
  * Dokumentation ist Bestandteil der API, Kommentare nicht

* ```graphql
  """
  A `Story` is the main object in our service.
  """
  type Story {
    """Identifies this object"""
    id: ID!

    # todo: implement new tags-field (PROJ-666)
  }
  ```

---

## Skalare Typen

* Skalare Typen entsprechen primitiven Typen in JavaScript
  * Sind die Enden im Objekt-Graphen
* Standard-Typen: ID, String, Boolean, Int, Float
  * ID wird als String gelesen und geschrieben, soll aber nicht interpretiert werden


* ```graphql
  type Member {
    id: ID!

    username: String!

    # no exclamation mark: can be null
    likes: Int

    amount: Float!

    activeMember: Boolean
  }
  ```
  

* Man kann eigene skalare Typen bauen
---

### Aufz√§hlungstypen (enum)

* Wie in TypeScript

* <!-- .element: style="min-width: 500px" -->
  ```graphql
  enum ReactionType {
    like,
    laugh,
    thumbUp
  }
  ```

---

### Referenzen

* Referenzen auf andere Objekt-Typen

* <!-- .element: style="min-width: 900px" -->
  ```graphql
  type Member {
    # ...
  }

  type Comment {
    # ...
  }

  type Story {
    """Reference to the Member that has written this Story"""
    writtenBy: Member!

    comments: [Comment!]!

  }
  ```

---

### Argumente

* Felder k√∂nnen Argumente haben
  * Solche Felder werden auch _Methoden_ genannt
* Die Felder mit ihren Namen und Typen m√ºssen in der API definiert werden
  * Namen sind entscheidend (wie in Objekten an Funktionsparametern in JS), nicht Reihenfolge (wie in JavaScript)
* Argumente k√∂nnen Default-Werte haben
* Achtung! Argumente d√ºrfen keine Objekt-Typen sein!  


* ```graphql
  type Story {

    # Mandatory argument maxLength, defaults to 20
    #  if not specified by the client
    excerpt(maxLength: Int! = 20): String!

  }
  ```

---

### Root-Typen

* Root-Typen bilden den Einstiegspunkt f√ºr Queries in den Objekt-Graphen
* Root-Typen sind **Query**, **Mutation** und **Subscription**
  * **Query** ist Pflicht, die beiden anderen Typen optional
* Syntax und Verhalten genauso wie bei Objekt-Typen
* Felder an den Root-Typen werden auch **Root-Felder** genannt


* ```graphql
  type Query {
    """Returns a List of all stories"""
    stories: [Story!]!

    """Returns a story by its ID or null"""
    story(id: ID!): Story
  }

  type Mutation {
    addComment(storyId: ID!, memberId: ID!, content: String!): Comment!
  }
  ```
---

### Input-Typen

* Objekt-Typen k√∂nnen nicht als Argument an ein Feld √ºbergeben
* Als Argumente an Feldern k√∂nnen nur skalare Typen, Enums und Input-Typen √ºbergeben werden.
* Ein Input-Type wird mit `input` definiert, sieht ansonsten aus wie ein Objekt-Type
  * Ein Input-Type darf keine Objekt-Typen referenzieren

* ```graphql
  input AddCommentInput {
    storyId: ID!
    memberId: ID!
    content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
  ```

---

### Union Types

* Union Types bilden eine Menge von anderen Typen
* Ein Feld kann ein Typen aus dieser Menge zur√ºckliefern ("A _oder_ B")


* ```graphql
  type AddCommentSuccess { newComment: Comment! }
  type AddCommentFailed { errorMessage: String! }

  union AddCommentResult = AddCommentSuccess | AddCommentFailed

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentResult!
  }
  ```


---

### Interfaces

* Mit einem Interface wird erzwungen, dass Objekte √ºber gleiche Felder verf√ºgen
  * Vergleichbar mit Interfaces in TypeScript


* ```graphql
  interface Node {
    id: ID!
  }

  type Story implements Node {
    id: ID!  # Field defined in Node-Interface

    title: String! # additional Story fields
  }

  type Comment implements Node {
    id: ID! 

    content: String!
  }

  type User {
    id: ID!
    email: String
  }

  type Query {
    # Returns either Story or Comment, but not User

    node(id: ID!): Node 
  }
  ```

---

### Schema-Evolution

* In GraphQL gibt es nur _eine Version_ der API (kein `/api/v1`, `/api/v2`)
* Das Schema kann jederzeit erweitert werden
  * Clients fragen explizit Felder ab, d.h. durch neue Felder werden sie nicht beeintr√§chtigt
* Man kann Felder mit `deprecated` markieren, um anzuzeigen, dass sie nicht genutzt werden sollen  

* ```graphql
  type Query {
    # Ausgangspunkt 
    getStoryById(id: ID!): Story
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story

    # Neues Feld, beeintr√§chtigt bestehenden Client nicht
    stories: [Story!]!
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story @deprecated("Use story instead")
    story(id: ID!): Story

    stories: [Story!]!
  }
  ```
---
### _Eine_ API f√ºr ganze Anwendung

* √úblicherweise hat eine Anwendung *eine* GraphQL API
  * In REST gibt es mehrere Endpunkte, die auf unterschiedliche Server verteilt sein k√∂nnen
  * GraphQL soll zentrale API sein
  * Untereinander kommunizieren die Services per REST o.√§.
---

### √úbung: Schema beschreiben

---

### Vorbereitung: Das Repository

* `workspace`: Hier arbeiten wir, bitte in der IDE √∂ffnen
  * Ggf. `pnpm install` ausf√ºhren
  * `pnpm dev` zum Starten ausf√ºhren
  * Das Projekt ist in TypeScript geschrieben, sollte aber auch mit JavaScript-Syntax funktionieren.
* `steps`: L√∂sungen f√ºr die einzelnen √úbungen
* `app`: Fertige Anwendung auch mit Frontend

---
### √úbung: Schema beschreiben
* <!-- .element: class="very-small" -->
* Vervollst√§ndige die Datei `src/graphql/schema.graphql` und beschreibe darin eine API, die folgende Objekt-Typen enth√§lt:
  * **Member** mit `id` und `profileImage`
  * **Story** mit `id`, `title`, `body`, `excerpt` und einer Referenz (`writtenBy`) auf den Member
    * Das `excerpt`-Feld soll ein Argument haben: `maxLength` vom Typ int (Pflicht)
  * Alle Felder in den beiden Typen sind Pflicht (non-nullable), das `id`-Feld ist vom Typ `ID` alle anderen Strings
* Lege den Query-Typen mit folgenden Feldern an:
  * `allStories`: Liefert eine Liste der `Story`-Objekte zur√ºck. Nicht nullable.
  * `story`: Liefert eine einzelne Story zur√ºck. Das Feld soll ein Argument haben: `storyId`. Das Feld kann `null` zur√ºckgeben
* F√ºge f√ºr das `story`-Feld Dokumentation hinzu
* Im Playground (http://localhost:4000/graphql) kannst Du deine API sehen und Queries formulieren, das Ausf√ºhren funktioniert nat√ºrlich noch nicht
* Eine m√∂gliche L√∂sung findest Du in `steps/01-schema`

---


<!-- .slide: id="api-implementieren" -->
## Implementieren der GraphQL API

---

### Apollo Graphql

* Urspr√ºnglich Open-Source GraphQL Server und Client
* Apollo bietet mittlerweile (kommerzielle) Services f√ºr alles rund um GraphQL an
* Teilweise auch propriet√§re Ideen, wie Federation und Supergraph

---
### Apollo Server

 * https://www.apollographql.com/docs/apollo-server/
  * "All-inclusive"-L√∂sung
  * "Standalone" Server oder als Middleware f√ºr Express
  * Integration in andere Webserver (wie Hapi) √§ndern sich von Version zu Version
  * Basiert auf der "reinen" JavaScript Referenz-Implementierung [graphql-js](https://github.com/graphql/graphql-js)
* "Playground" zur Ausf√ºhrung von Queries
* Caching von Ergebnissen
* Automatic persisted queries: Queries per ID ausf√ºhren
* "Federation": Zusammenf√ºhren verschiedener GraphQL APIs

---

### Verarbeitung eines GraphQL Queries (allgemein)


1. <!-- .element: class="xx-list" --> Query kommt an (HTTP Endpunkt)
2. Query wird geparst und validiert
3. Ung√ºltige Queries werden abgewiesen (`errors`-Feld in der Antwort)
4. F√ºr jedes Feld wird eine *Resolver-Funktion* aufgerufen, die verantwortlich daf√ºr ist, die Daten f√ºr das jeweilige Feld zu liefern
5. Die Ergebnisse der Resolver werden validiert (insb. hinsichtlich der Typen)
6. Das Ergebnis wird als `data`-Feld bereitsgestellt
7. Das Ergebnis wird an den Client zur√ºckgeschickt

<!-- end of the list -->

* <!-- .element: class="note" --> Unsere Aufgabe ist es, die Resolver-Funktionen zu implementieren
---

### Apollo Server

* **Konfiguration und Start** √ºber `ApolloServer`-Objekt
* Der Server erwartet ein *executable Schema* (Schema-Beschreibung und Resolver-Funktionen)
* Je nach Laufzeitumgebung kann der Server standalone laufen (Express integriert) oder explizit in eine
            vorhandene Express Instanz integriert werden
* ```javascript
  import { ApolloServer } from "@apollo/server";

  const typeDefs = /* sp√§ter */
  const resolvers = /* sp√§ter */

  const schema = makeExecutableSchema({ typeDefs, resolvers });
  const app = express();
  const httpServer = http.createServer(app);
  const server = new ApolloServer({
      schema,
  });

  await server.start();

  app.use("/graphql",
      expressMiddleware(server)
  );

  httpServer.listen({ port: 4000 });
  ```

---

### Bereitstellen des Schemas

* Das Schema wird grunds√§tzlich mit der SDL beschrieben
* Entweder in externer Datei oder direkt im Source-Code
* Beispiel 1: Direkt im Source Code
  * ```javascript
  // language=GraphQL
    const typeDefs = `
      type Query { ping: String! }
    `
  ```
* Beispiel 2: Aus Datei lesen
  * ```javascript
  const typeDefs = readFileSync(
    path.resolve(__dirname, "graphql/schema.graphql"),
    "utf8"
  );
  ```


---

### Resolver

* **Ein Resolver liefert den Wert f√ºr ein angefragtes Feld in einer Operation**
* Zwingend erforderlich f√ºr jedes Root-Field (in den Query, Mutation und Subscription-Types)
  * falls keine Resolver-Funktion hinterlegt ist f√ºr ein Feld, greift ein Default Resolver
  * der Default-Resolber ermittel die Werte an Hand von Feldern oder Funktionen an Objekten
* Ein Resolver kann einen Wert zur√ºckliefern oder ein Promise f√ºr den Wert

---

### Beispiel: Resolver-Funktionen

* <!-- .element: class="demo" --> Demo: Resolver- mit Person-Feld
* <!-- .element: class="demo" --> Schema-Mapping! (fullname)
* <!-- .element: class="demo" --> Argumente!

---

### Resolver-Funktionen
* Resolver werden in der *Resolver Map* gehalten. Das ist ein JavaScript-Objekt:
* Key darin ist der Name eins GraphQL Objekts (z.B. `Query` oder `Story`)
* Als Wert dazu ist ein weiteres Objekt mit den Resolver-Funktionen hinterlegt:
  * In diesem Objekt ist der Key der Name eines Feldes an dem GraphQL Typen
  * Der Wert ist eine Funktion, die den Wert f√ºr das Feld ermittelt
* Beispiel f√ºr einen *Root*-Resolver:
  * ```javascript
    const resolvers = {
      Query: {
        ping: () => "Hello World"
      }
    }
    ```
---
### Resolver-Funktionen
* Signatur 1: `feldname(source, args, context, info): Wert`
* Signatur 2: `feldname(source, args, context, info): Promise<Wert>`
* Resolver-Funktionen k√∂nnen drei Argumente entgegennehmen:
  1. Das Source- oder Parent-Objekt
  2. Die f√ºr das Feld √ºbergebenen Argumente
  3. Das GraphQL Context-Objekt
  4. Meta-Informationen √ºber den Query
---

### Resolver-Funktionen: Argumente

* Die an ein Feld √ºbergebenen Argumente werden in einem Objekt an das _zweite_ Argument des Resolvers √ºbergeben
* Es werden nur Werte √ºbergeben, die gem√§√ü Schema g√ºltig sind
  * Bei nicht g√ºltigen Werten wird der Query abgelehnt
* ```graphql
  type Story { id title body }

  type Query {
    story(storyId: ID): Story
  }
  ```
* ```javascript
  const resolvers = {
    Query: {
      story(_, { storyId }) {
        return db.getStoryById(storyId);
      },
    }
  }
  ```
---
### Resolver-Funktionen: Das Parent-Objekt
* Alle nicht-Root-Resolver bekommen ihr jeweiliges Parent-Objekt als ersten Parameter √ºbergeben
* Das Parent-Objekt ist das Objekt, das der vorherige Resolver zur√ºckgeliefert hat
* ```graphql
  type Story {
    id title body
    excerpt(maxLength: Int! = 10)  # excerpt nicht am JavaScript Story Object!
  }

  type Query {
    story(storyId: ID!): Story
  }
  ```
* ```javascript
  const resolvers = {
    Query: { /* wie gesehen... */ },
    Story: {
      excerpt(story, { maxLength } ) {
        return story.body.substring(0,maxLength);
      }
    }
  }
  ```
---
### Resolver-Funktionen: Das Context-Objekt
* Mit dem Context-Objekt k√∂nnen Informationen pro Query erzeugt und an alle Resolver √ºbergeben werden
  * Zum Beispiel Header aus dem HTTP Request (Authorization, ...)
* Mehr dazu sp√§ter
---
### Resolver f√ºr Mutations

* Resolver f√ºr den Mutation-Typen werden ebenfalls in die ResolverMap aufgenommen.
* Signatur der Funktionen ebenfalls identisch
* Einziger (semantischer) Unterschied: in den Mutation Resolvern d√ºrfen Daten ver√§ndert werden
* ```javascript
  const resolvers = {
    Query: { /* ... */ },

    Mutation: {
      addComment(_, { input }) {
        return publyDomainService.addCommentToPost(input.storyId, input.content);
      }
    }
  }
  ```
---
### Resolver registrieren

* Die Resolver werden an die `ApolloServer`-Instanz √ºbergeben
  * Entweder als `executableSchema`
    * ```javascript
      const resolvers = { Query: { /* ... */ } };
      const schema = makeExecutableSchema({ typeDefs, resolvers });
      const server = new ApolloServer({
        schema,
        // ...
      })
      ```
  * Oder als eigene Konfigurationsoption
    * ```javascript
      const resolvers = { Query: { /* ... */ } };
      const server = new ApolloServer({
        typeDefs,
        resolvers
        // ...
      })
      ```
---
### Resolver modularisieren
* Nat√ºrlich k√∂nnt ihr die Resolver auch auf unterschiedliche Module aufteilen
* Beispiel:
  * ```javascript
    import { queryResolvers } from "./query.resolver"; // { story() { ... } }
    import { storyResolvers } from "./query.resolver"; // { excerpt() { ... } }

    const resolvers = {
      Query: queryResolvers,
      Story: storyResovers
    }

    const server = new ApolloServer({
        typeDefs,
        resolvers
        // ...
    })
    ```
---

### √úbung: Resolver implementieren

* **Implementiere die Resolver f√ºr `Query.allStories`, `Query.story` und `Story.excerpt`**
* Du musst die √Ñnderungen in `src/graphql/resolver.ts` machen (Du brauchst keine TypeScript-Typen hinschreiben)
* Zum Ermitteln der Story bzw. Stories kannst Du den `publyDomainService` verwenden, der aus `src/domain/PublyDomainService.ts` exportiert wird
* Das `Story.excerpt` Feld soll die ersten `maxLength` Zeichen aus dem `body`-Feld Story zur√ºckliefern. (Erinnerung: `maxLength` ist ein Argument am `excerpt`-GraphQL Feld)
* Falls Du mit der √úbung 1 (Schema beschreiben) nicht fertig geworden bist, kopiere dir `steps/01-schema/src/graphql/schema.graphl`
          in dein Workspace-Verzeichnis
* Wenn Du die drei Resolver korrekt implementiert hast, m√ºssen die Queries auf der folgenden Slide funktionieren
* Eine L√∂sung findest Du im Verzeichnis `steps/02-resolver`

---
### √úbung: Resolver #2
* Der folgende Query sollte funktionieren, wenn Du den Resolver f√ºr `allStories` korrekt implementiert hast:
  * ```graphql
    query {
      allStories {
        id title body
        writtenBy { id profileImage }
      }
    }
    ```

* Der Query sollte funktionieren, wenn Du den `Query.story`-Resolver implementiert hast:
  * ```graphql
    query {
      story(storyId: "1") {
        id title body
        writtenBy { id profileImage }
      }
    }
    ```
* Der Query sollte funktionieren, wenn Du den `Story.excerpt`-Resolver implementiert hast (die Werte f√ºr
            das `excerpt`-Feld sollten dann nat√ºrlich max. zehn Zeichen lang sein üòâ
  * ```graphql
    query {
      allStories {
        id
        title
        excerpt(maxLength: 10)
      }
    }
    ```
---
### Resolver: Union-Types

* Wenn ein Resolver einen Union-Typen zur√ºckliefert, muss Apollo wissen, welchem GraphQL-Typen dein Resolver-Ergebnis entspricht
* Beispiel Mutation:
  * ```graphql
    type AddStorySuccess { storyAdded: Story! }

    type AddStoryFailed { error: String! }

    union AddStoryResponse = AddStorySuccess | AddStoryFailed

    type Mutation {
      addStory(input: AddStoryInput!): AddStoryResponse!
    }  
    ```
* Apollo muss wissen, ob das zur√ºckgelieferte (JavaScript-)Objekt vom Resolver f√ºr `Mutation.addStory` dem GraphQL Typen `AddStorySuccess` oder `AddStoryFailed` entspricht
* Dazu musst Du einen Resolver mit dem Namen `__resolveType` bauen und zwar f√ºr den Union-Typen (hier also `AddStoryResponse.__resolveType`)
* Diese Funktion wird dann mit dem Ergebnis eines Resolvers aufgerufen, der den Union-Typen zur√ºckgegeben hat (`Mutation.addStory`)
* Die Resolver-Funktion muss dann pr√ºfen, um welche konkrete Auspr√§gung des Union-Types es sich handelt und den Namen des GraphQL-Typen als String zur√ºckliefern (`"AddStorySuccess"` oder `"AddStoryFailed"`)

---
### Resolver: Union-Types
<!-- .slide: class="left" -->
* Beispiel:
* ```javascript
  const resolvers = {
    // ...
    AddStoryResponse: {
      __resolveType(addStoryResult) {

        // Annahme: das addStoryResult JS-Objekt enth√§lt
        // ein Feld "storyAdded", wenn es ein "erfolgreiches"
        // Ergebnis ist. 

        if ("storyAdded" in addStoryResult) {
          return "AddStorySuccess";
        }
        return "AddStoryFailed";
      },
    },
  }
  ```
---

---
## √úbung: Union Types und Context
* **Implementiere die Resolver f√ºr `addComment`**
*  Du kannst dir das Schema von der n√§chsten Slide kopieren und in `schema.graphql` einf√ºgen
*  Implementiere die fehlenden Resolver: `Mutation.addComment` 
  * Zum Speichern des Kommentars kannst Du `publyDomainService.addComment` aufrufen. √úbergib f√ºr den `userId`-Parameter im ersten Schritt einfach `U1`
  * Wenn ein Fehler fliegt, fange diesen mit `catch` auf und gib den Fehlertypen zur√ºck. Ansonsten gib den neuen Kommentar als `AddCommentSuccessPayload`-Typen
    zur√ºck
* Implementiere au√üerdem den `__resolveType`-Resolver f√ºr den Union-Typen
*  Wenn alles korrekt implementiert ist, sollte im ersten Schritt folgende Mutation funktionieren:
   * Erfolg: ..
   * Fehler: ---
* Bef√ºlle den Context: in `a.ts` aus dem Express HTTP-Request das `X-Authorization`-Header auslesen (TODO: BEISPIEL)
  * Erzeuge ein Context-Objekt mit einer `userId`-Eigenschaft. Wenn der `X-Authorization`-Header gesetzt ist,
    setze `userId` auf diesen Wert (so dass der Header in den Resolvern zur Verf√ºgung steht). Ist der Header nicht vorhanden
    oder leer, setze `userId` auf `null`
  * Registriere die `createContext`-Funktion in  `TODO....`
* Pr√ºfe im Mutation-Resolver von `addComment` ob eine userId im Context steht.
  * Wenn nein: liefer den AddCommentFailedPayload-Typen mit einer Fehlermeldung zur√ºck (z.B. "Please login")
    * Vielleicht Exception werfen und vergleichen: https://www.apollographql.com/docs/apollo-server/data/resolvers#the-context-argument
  * Wenn ja: verwende `userId` f√ºr den Aufruf von `publyDomainService.addComment`
  * Nun sollte folgende Mutation funktionieren: HEADER....
---
### Fehlerbehandlung

* Zwei Arten:
  * Ein Feld gibt ein "fachliches" Fehler-Objekt zur√ºck (wie gesehen, z.B. `AddStoryFailed`)
  * Nicht behandelte (technische) Fehler werden √ºber das `errors`-Objekt an den Client geschickt
    * (trotzdem HTTP Status Code 200!)
* Das `errors`-Feld ist nicht genau spezifiziert und dessen Inhalt kann auch nicht im Schema beschrieben werden
* Deswegen sollte es nur f√ºr Ausnahmen verwendet werden, z.B. wenn der Query gar nicht ausgef√ºhrt werden kann, zum Beispiel, weil der Query ung√ºltig ist:
* ```json
  {
    "data": {},
    "errors": [
      {
        "message": "Cannot query field 'cmment' on type 'AddCommentSuccessPayload'.",
        "locations": [ { "line": 4, "column": 7 }
        ],
        "extensions": {
          "code": "GRAPHQL_VALIDATION_FAILED",
        }
      }
    ]
  }
  ```
---

### GraphQLErrors

* Neben dem Fehler (`message`) und der Angabe, bei welchem Feld im Query ein Fehler (`locations`) aufgetreten ist, gibt es ein `extensions`-Feld, das von GraphQL Servern
bef√ºllt werden kann.
* Apollo sendet darin einen `code` und ggf. den Stacktracke
* Das `extensions`-Feld kannst Du selbst setzen, in dem du einen `GraphQLError` in deinem Resolver wirfst.
  * Der `GraphQLError` erwartet im Konstruktor die Fehlermeldung und ggf. ein eigenes `extensions`-Objekt:
  * ```javascript
      throw new GraphQLError("Please log in", {
        extensions: {
          code: "INVALID_CREDENTIALS",
          requestId: "4129374981234"
        },
      });
      ```
  * Ergebnis:      
  * ```json
    {
      "errors": [
        {
          "message": "Please log in",
          "locations": [ { "line": 4, "column": 7 } ],
          "extensions": {
            code: "INVALID_CREDENTIALS",
            requestId: "4129374981234"
          }
        }
      ]
    }
    ```      

---
## Der GraphQL Context
---
### Der GraphQL Context

* Vor jeder Ausf√ºhrung eines GraphQL Requests vom Client kannst Du ein Context-Objekt erzeugen
* Das Context-Objekt ist ein regul√§res JavaScript-Objekt, das Du nach deinen Anforderungen bef√ºllen kannst
* Das Context-Objekt wird jeder Resolver-Funktion √ºbergebeen, die im Zuge des Requests aufgerufen wird.
* Typische Verwendung zum Beispiel zum √úbergeben des angemeldeten Benutzers oder auch Zugriff auf Daten-Quellen (z.B. DB Verbindung)

---

### Der GraphQL Context

<!-- .element: class="demo" --> `X-Authorization` aus Request-Header lesen
<!-- .element: class="demo" --> Im `ping`-Resolver auslesen

---

### Der GraphQL Context

* Deine Funktion zum Erzeugen des Context-Objektes wird von Apollo vor jedem Request ausgef√ºhrt
* Der `context`-Funktion wird ein `config`-Objekt √ºbergeben. Wie das genau aussieht, h√§ngt von der Server-Konfiguration und den verwendeten Plug-ins ab
  * In der Regel hast Du aber zumindest das Express Request (`req`) und Response (`res`) Objekt darin
* Die Funktion muss ein Promise mit deinem Context-Objekt aufrufen
* ```javascript
  async function createPublyContext(config) {
    const context = {
      userId: config.req.get("X-Authorization") || null;
    };

    return context;
  }
  ```
---
### Der GraphQL Context
* Die Funktion kannst Du entweder direkt am `ApolloServer` oder in der `expressMiddleware` angeben:

* ```javascript
  const app = express();
  const server = new ApolloServer({ /* ... */ });
  // ...

  app.use(
    "/graphql",
    cors(), json(),
    expressMiddleware(server, { context: createPublyContext })
  );
  ```  
* In unserer Beispiel-Anwendung geben wir die `context`-Funktion bei der `expressMiddleware` an, weil wir sp√§ter auch den Apollo Cache ben√∂tigen, auf den wir
  nur dort Zugriff haben. Ansonsten ginge auch:
* ```javascript
  const app = express();
  const server = new ApolloServer({ 
    // ...
    context: createPublyContext
  });
  // ...
  ```  
---
### √úbung: GraphQL Context

* Kontext mit userId erzeugen
* Im MutationREsolver userId pr√ºfen, falls nicht gesetzt => GraphQLError (code: NOT_LOGGED_IN)
* Falls gesetzt, an Publy Domain Service √ºbergeben
---

## Daten aus anderen Systemen integrieren (DataSources)
--

### DataSources

* Wir k√∂nnen beliebige Datenquellen (DB, REST APIs, andere GraphQL APIs) in unseren Resolvern verwenden, um die ben√∂tigten Daten zu ermitteln
* Weder die GraphQL Spezifiktatio noch Apollo machen eine Aussage/stellen eine Anforderung, wo die Daten herkommen m√ºssen
* Ihr k√∂nnt also einfach Eure Lieblingslibraries benutzen, die ihr ohnehin schon f√ºr den Zugriff auf Datenbank etc. benutzt

* Aber es gibt ein paar Klippen!

---

### Zugriff auf "externe" Datenquellen ist potentiell teuer!

* Wir k√∂nnen Felder im Schema mit der Direktive `cacheControl` markieren
* Damit k√∂nnen wir steuern, wie lange ein Feld "g√ºltig" ist
  * Der entsprechende Resolver wird dann nicht aufgerufen, sondern der Wert wird aus dem Cache geliefert
* Wenn mehrere Felder in einem Query abgefragt sind, die im Schema mit `cacheControl` als cachebar gekennzeichnet sind,
entscheidet die k√ºrzeste Cache-Dauer

<!-- .element: class="demo" --> Cache-Control am ping-Feld mit Zeitstempel Datum
<!-- .element: class="todo" -->BEISPIEL VORBEREITEN
---
### Laufzeitverhalten
<!-- .slide: class="left" -->
* Was passiert bei diesem Query?
* ```graphql
  query {
    allStories {   # Story
      writtenBy {  # Member
        user {     # User
          id fullname
        }
      }
    }
  }
  ```
* ```javascript
  const resolvers = {
    Query: { 
      allStories() { return publyDomainService.findAllStories() }
    },
    Member: {
      user(member) {
        return userRestService.getUserForId(member.user_id)
      }
    }
  }
  ```
* *1+n-Problem üò±*  
* ```javascript
  const resolvers = {
    Query: { 
      allStories() { return publyDomainService.findAllStories() } // EIN Datenbankzugriff (liefert n Stories)
    },
    Member: {
      user(member) {
        return userRestService.getUserForId(member.user_id) // n REST-Aufrufe (1x pro Story-Member)
      }
    }
  }
  ```
---
### Apollo RESTDataSource

* `RESTDataSource` kann f√ºr den Zugriff auf externe System per REST API verwendet werden
* Kann Antworten cachen
* Gab bis Apollo Server v3 [weitere DataSource-Implementierungen](https://www.apollographql.com/docs/apollo-server/v3/data/data-sources), u.a. f√ºr SQL. Scheinen in v4 entfernt worden zu sein.
<!-- .element: class="demo" --> Beispiel DataSource mit Caching am UserService



---
## TypeScript

* Typen generieren
* Typen f√ºr Resolver
* Typen f√ºr Context
* Typen im Client und end2end-Typisierung

---



### Laufzeitverhalten  
* **Datenzugriff

            ### DataFetchingEnvironment (graphql-java)

* Jeder DataFetcher bekommt zur Laufzeit ein `DataFetchingEnvironment` √ºbergeben
* Dieses enth√§lt unter anderem die an ein Feld √ºbergebenen Argumente
* ```java
  class PingFetcher<String> {
      @Override
      public String get(DataFetchingEnvironment env)  {
        String msg = env.getArgumentOrDefault("msg", "Pong");
        return msg;
      }
  }
  ```
* Oder das `source`-Objekt, das das Ergebnis des √ºbergeordneten DataFetchers zur√ºckliefert:
* ```java
  class ExcerptFetcher<Sring> {
      @Override
      public String get(DataFetchingEnvironment env)  {
        Story story = env.getSource();
        return story.getBody().substring(0, 7);
      }
  }
  ```
---

### RuntimeWiring

* Im `RuntimeWiring` werden u.a. alle `DataFetcher` den Felder in unserem Schema zugewiesen
* Um eine Instanz davon zu erzeugen, wird ein `RuntimeWiringBuilder` verwendet
* An diesem werden f√ºr jeden Typ aus unserem Schema (auch `Query`, `Mutation`, `Subscription`)
            DataFetcher-Instanzen zu Feldern zugeordnet
* ```java
    RuntimeWiring wiring = RuntimeWiring.newRuntimeWiring()
      .type("Query", builder -> {
        return builder
          .dataFetcher("stories", new QueryStoriesDataFetcher())
          .dataFetcher("story", new StoryByIdDataFetcher());
      })
      .type("Story", builder -> {
        return builder.dataFetcher("excerpt", new ExcerptDataFetcher());
      })
      .build();
  ```

---


## GraphQL Java Architektur


<img src="images/graphql-java-architektur.png" />

---
### √úbung: Hello, GraphQL-Java!

* Im `hello-graphql-java`-Projekt fehlen die DataFetcher üò±
  * Bitte implementiere die drei DataFetcher dort (s. TODOs in den einzelnen Dateien)
* F√ºge deine DataFetcher in `GraphQLProvider` zum `RuntimeWiring` hinzu
* Zur Kontrolle f√ºhre die Tests in `nh.publy.QueryTest`, die nun "gr√ºn" werden sollten
* M√∂gliche L√∂sung `hello-graphql-steps/02-datafetcher`

---

## Exkurs: Spring und Spring Boot
<!-- .slide: id="exkurs-spring" -->

* Wir gucken uns hier nur an, was f√ºr diesen Workshop relevant ist und nur sehr oberfl√§chlich

---
### Spring

<!-- .element: class="demo" --> DI
<!-- .element: class="demo" --> Neues Spring-Projekt mit MVC und Spring Data
---

### Spring

#### Der Kern: Ein Container f√ºr Beans

* Dependecy Injection Container
  * IoC: Abh√§ngige Objekte werden √ºbergeben (und nicht abgefragt)
  * In Spring "Beans" genannt
  * Spring erzeugt die Beans und √ºbergibt ben√∂tigte abh√§ngige Beans
* AOP Container
  * z.B. f√ºr Transaktionen oder Sicherheit

---
### Spring: Dependency Injection

* Beans werden mit `@Component` annotiert
  * Darauf aufbauend gibt es "semantische" Annotation wie `@Controller` oder `@Service`
* Alle Klassen, die so annotiert sind, werden automatisch im Klassenpfad gefunden ("classpath scanning")
* Die Klassen werden von Spring instantiiert und im Application Context registriert
* Spring sorgt daf√ºr, dass Abh√§ngigkeiten √ºbergeben werden
---
### Spring: Dependency Injection

* Beans k√∂nnen Abh√§ngigkeiten auf andere Beans definieren
* Im einfachsten Fall im Construktor, wenn es genau einen gibt:
* ```java
  @Service
  public DomainService {
    private final DbService dbService;

    // DbService wird von Spring √ºbergeben
    public DomainService(DbService dbService) {
      this.dbService = dbService;
    }
  }
  ```
---
### Spring: Dependency Injection
* Mit `@Autowired` oder `@Inject`-Annotationen an Feldern, Konstruktoren oder (Setter-)Methoden:
* ```java
  @Service
  public DomainService {
    private DbService dbService;

    @Autowired
    private MailService mailService;

    private UserService userService;

    // Mehrere Konstruktoren => Autowired erforderlich, falls
    //  einer davon von Spring genutzt werden soll
    public DomainService() {
    }

    @Autowired
    public DomainService(DbService dbService) {
      this.dbService = dbService;
    }

    @Autowired
    public void setUserService(UserService userService) {
      this.userService = userService;
    }
  }
  ```
* In der Regel sollte man sich f√ºr eine Technik entscheiden
  * Als aktuelle Best-Practice gilt Konstruktor-Injektion ohne Autowired
  * Dann k√∂nnen die Beans, z.B. im Test, auch selbst erzeugt werden

---
### Stereotypen

* Klassen werden mit `@Component` annotiert, um sie zu Beans zu machen
* Es gibt davon abgeleitet einige Annotation, die er erlauben, eine Bean semantisch einzuordnen:
  * `@Service`, `@Repository`, `@Controller`, `@RestController`
  * Teilweise f√ºgen diese Annotationen einer Bean neue Features hinzu
* Sie erlauben, die Beans nach Fachlichkeit zu organisieren und Architektur-Regeln einzuhalten
  * `@Repository` sollte normalerweise z.B. nicht auf `@Service` zugreifen
* Man kann eigene solcher *Stereotypen*-Annotationen erzeugen

---
### Konfiguration: Application Properties

* Spring-Anwendungen k√∂nnen √ºber Properties konfiguriert werden
* Per Default wird eine Datei `application.properties` daf√ºr verwendet
* Die Datei wird von Spring automatisch eingelesen
* Die Properties stehen der Anwendung dann zur Verf√ºgung
* Zum Zugriff gibt es diverse M√∂glichkeiten
  * ```java
  // Beispiel: @Value injiziert einen Wert
  @Value("${my.app.db-url}")
  private String dbUrl;
  ```
  * ```java
    // Beispiel: Environment enth√§lt alle Properties
    @Autowired
    private Environment environment;

    public String getDatabaseUrl() { return environment.get("my.app.db-url"); }
    ```
---
### Spring: Unterst√ºtzte Technologien

* Spring bietet eine Abstraktion f√ºr diverse popul√§re Technologien
  * JPA (Persistenz) und deklarative Transaktionen
  * Messaging (JMS, Kafka, RabbitMQ, ...)
  * Webservices mit und ohne REST (Spring MVC)
  * JSP, Servlet (Spring MVC)
  * REST Client
  * Asynchrone Aufrufe mit Scheduler
* Der Zugriff darauf ist unabh√§ngig davon, wie Spring zur Laufzeit eingesetzt wird (im Servlet-Container
   oder Standalone)

---
### Web-Anwendungen und REST-Services: Spring MVC
* Spring MVC ist urspr√ºngliche eine Abstraktion u.a. √ºber Servlets (und Template-Sprachen)
  * In einer `@Controller`-Klasse werden Endpunkte beschrieben und auf Pfade gemappt
  * Die Methoden geben ein Model zur√ºck
  * Spring sucht zu der Methode eine View heraus (z.B. JSP- oder Thymeleaf-Template)
* Spring MVC wird mittlerweile auch f√ºr REST-APIs verwendet
  * Dann wird kein Template zur√ºckgeben, sondern ein Objekt, das automatisch nach JSON konvertiert wird
* Das Programmiermodell ist immer identisch, unabh√§ngig, in welchem Container die Anwendung ausgef√ºhrt wird

---
### Java Persistence API: JPA

* JPA ist eine Standard API f√ºr ORM-Tools
* Prominenteste Implementierung ist Hibernate, das in den meisten F√§llen verwendet wird
* In JPA kann das DB-Mapping von *Entities* beschrieben werden
* Der JPA-Provider sorgt daf√ºr, dass Daten aus der DB in die Entity-Klassen gemappt und zur√ºckgeschrieben werden
* üëâ F√ºr unseren Workshop spielen Details keine Rolle, deswegen lassen wir das hier aus

---
### Spring: Datenzugriff

* Spring unterst√ºtzt diverse Persistenz-Technologien, z.B. JPA, natives SQL oder MongoDB
* Unabh√§ngig von der Technologie werden Daten in der Regel √ºber _Repositories_ verwaltet
  * Der Begriff kommt aus dem Domain Driven Design und beschreibt Akteure, die daf√ºr Zust√§ndig sind,
    Daten aus einer Quelle zu ermitteln
* Ein Repository wird in Spring mit der Annotation `@Repository` gekennzeichnet
* Je nach Technologie ist die Implementierung dann aber unterschiedlich

---
### Spring Data

* [Spring Data](https://spring.io/projects/spring-data) stellt eine einheitliche Abstraktion f√ºr mehrere Persistenz-Technologien
  zur Verf√ºgung (z.B. Spring Data f√ºr JDBC, f√ºr JPA oder f√ºr MonogoDB)
* Beschrieben werden in der Anwenung daf√ºr Interfaces, die Repositories genannt werden und auch ein
  Interface `Repository` implementieren m√ºssen
* Spring Data stellt dann daf√ºr Implementierungen zur LAufzeit zur Verf√ºgung
* √úber Namenskonventionen k√∂nnen z.B. Query-Funktionen definiert werden
* ```java
  public interface StoryRepository extends CrudRepository<Story, Long> {
  }
  ```
* ```java
  public StoryService {
    private final StoryRepository storyRepository;
    public StoryService(StoryRepository sr) { this.storyRepository = sr; }

    @Transactional
    public void updateStory(Long storyId, String newTitle) {
      storyRepository.findById(storyId).ifPresent(
            story -> { story.setTitle(newTitle); storyRepository.save(story); }
      );
  }
  ```

---
### Spring Boot
* Das (initiale) Erstellen von Spring-Anwendungen kann sehr komplex sein
  * Je nach Technologie-Stack viele Abh√§ngigkeiten (Jars) zu verwalten
  * Viele "Technik" Beans zu erzeugen und zu konfigurieren
* Spring Boot nimmt einem davon viel ab
  * Es gibt einen Projekt-Generator, https://start.spring.io
* Es gibt "Starter", das sind Spring Module f√ºr diverse Technologien, die oft gebrauchte
  Dinge zur Verf√ºgung stellen (z.B. Datenbank-Support, Transaktionen, REST Endpunkte etc.)
* Zur Laufzeit ermittlt Spring Boot an Hand der im Klassenpfad befindlichen Starter, welche
  Technik im Projekt eingesetzt wird (z.B. JPA und welche Datenbank)
* Die Beans daf√ºr werden dann automatisch erzeugt und konfiguriert

---
### √úbung: Spring Boot

* `Hello GraphQL Java` auf Spring Boot portieren!
* Markiere das `StoryRepository` als `Repository`
* Markiere deine DataFetcher als `Component` oder `Service`
  * Die Story-DataFetcher sollen das `StoryRepository` per Dependency Injection bekommen
* Markiere den `GraphQLProvider` als `Service`
  * Der `GraphQLProvider` soll die drei DataFetcher per Dependency Injection erhalten
  * Das `StoryRepository` wird im `GraphQLProvider` nicht mehr ben√∂tigt und kann entfernt werden.
* Erzeuge die Klasse `nh.publy.HelloGraphQLApplication`
  * Den Inhalt daf√ºr findest Du im `hello-graphql-java/material`-Verzeichnis (einfach kopieren und in `.java` umbenennen)
* Stelle den `QueryTest` auf einen `SpringBootTest` um:
  * Annotiere ihn mit `@SpringBootTest`
  * Den GraphQL-Provider nicht mit `new` erzeugen, sondern einfach mit `@Autowired` markieren
* Nun sollten die `QueryTest` einen Spring-Server starten und nat√ºrlich weiterhin gr√ºn sein.
---

<!-- .slide: id="spring-for-graphql" -->
## Spring for GraphQL


* [Spring for GraphQL](https://spring.io/projects/spring-graphql) bietet eine Abstraktion von GraphQL-Java an
* Erstes Release von Spring for GraphQL enthalten in Spring Boot 2.7 (Mai 2022)
  * Projekte k√∂nnen mit dem [Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.7.3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=graphql) erzeugt werden

* Features:
  * Automatische Konfiguration des RuntimeWirings
  * HTTP-Endpunkt f√ºr Requests und Subscriptions automatisch
  * GraphiQL Integration per Property
  * Gewohntes Spring-Programmiermodell mit Annotationen etc.
  * Integration in Spring Stack (z.B. Bean Validation, Security)
  * [`spring-boot-starter-graphql`](https://docs.spring.io/spring-boot/docs/2.7.3/reference/htmlsingle/#web.graphql) f√ºr Spring Boot
  * Actuator-Endpunkte f√ºr Spring Boot

---

### Das Schema in Spring for GraphQL

* Das Schema wird in Dateien mit der Endung `.graphqls` abgelegt
  * Verzeichnis: `main/resources/graphql`
* Spring Boot sammelt alle Schema-Dateien ein und erzeugt ein Schema daraus
* Typen k√∂nnen erweitert werden

* <pre class="fragment"><code class="graphql">
  # story.graphqls
  extend type Query {
    story(id: ID!): Story
  }

  # comment.graphqls
  extend type Query {
    comment(id: ID): Comment
  }
</code></pre>
---

## Spring for GraphQL

* <!-- .element: class="demo" --> Demo: Handler-Funktionen mit `ping`-Feld
* <!-- .element: class="demo" --> Query-Mapping!
* <!-- .element: class="demo" --> Argumente!

---

## Handler-Funktionen


* Anstatt `DataFetcher` werden *Handler-Funktionen* an `Controller`-Klassen implementiert

  * ```java
    @Controller
    public GraphQLController {

      @QueryMapping
      public String ping() { return "Pong!" }

    }
    ```
  
  * Handler-Funktionen f√ºr Felder am Query-Typen werden mit `@QueryMapping` annotiert
    * Mutations: `@MutationMapping`, Subscription: `@SubscriptionMapping`
  * Der Name der Methode entspricht dem Namen des Feldes des entsprechenden Root-Typen (oder explizit mit `value` setzen)

---

### Parameter von Handler-Funktionen

* `@Argument` um ein einzelnes Argument zu erhalten
* ```graphql
  type Query {
    ping(msg: String): String!
  }
  ```
* ```java
  @QueryMapping
  public String ping(@Argument String msg) { 
    return "Hello " + msg; 
  }
  ```  
* `@Arguments`, um Parameter in einer Java-Klasse zusammenzufassen
* ```graphql
  type Query {
    greet(name: String, msg: String): String!
  }
  ```

* ```java
    class GreetingParams { private String name; private String msg; /* getter+setter... */ }

    @QueryMapping
    public String greet(@Arguments GreetingParams params) { 
      return "Hello " + params.getName(); 
    }
  ```
* `@ProjectedPayload` um einzelne Parameter in einem Interface zusammenzufassen
* ```graphql
    type Query {
      greet(name: String, msg: String): String!
    }
  ```

* ```java
    @ProjectedPayload
    interface GreetingParams { String getName(); String getMsg(); }

    @QueryMapping
    public String greet(@Argument GreetingParams params) { 
      return "Hello " + params.getName(); 
    }
  ```

---
### Parameter von Handler-Funktionen  
  
* F√ºr Input-Typen kann ein Pojo angegeben werden:
* ```graphql
  input GreetingInput { name: String, msg: String }

  type Query {
    greet(input: GreetingInput!): String!
  }
  ```
* ```java
  class GreetingInput { private String name; private String msg; /* getter+setter... */ }

  // oder Java 17 Records:
  record GreetingInput(String name, String msg) {}

  @QueryMapping
  public String greet(@Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  
* Argumente k√∂nnen mit Bean Validation validiert werden
* ```java
  class GreetingInput { @Size(min=5) private String name; private String msg; /* getter+setter... */ }

  @QueryMapping
  public String greet(@Valid @Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  

---

## √úbung: Handler-Funktionen
---


### Vorbereitung: Starten der Anwendung

* Ab jetzt arbeiten wir in der "Publy"-Beispiel-Anwendung
* Diese besteht aus zwei Spring Boot Anwendungen: `publy-userservice` und `publy-backend`

* Schritt 1: User Service starten
  * Entweder in der IDE `nh.graphql.publy.userservice.UserserviceApplication` starten
  * oder: im `workspace`-Verzeichnis: `./gradlew :publy-userservice:bootRun`
  * Diese Anwendung kann die ganze Zeit durchlaufen, wir machen hier keine √Ñnderungen
* Schritt 2: Backend starten
  * Entweder in der IDE `nh.publy.backend.PublyApplication` starten
  * oder: im `workspace`-Verzeichnis: `./gradlew :publy-backend:bootRun`
  * Nach √Ñnderungen (und Speichern, Compilieren) sollte sich das Backend automatisch neu starten

---

### √úbung: Handler-Funktionen

* Kopiere dein Schema aus der `hello-graphql-java`-√úbung (oder aus dem `01-schema`-Verzeichnis)
  nach `publy-backend/src/main/resources/graphql` (bestehendes Schema √ºberschreiben)
* Implementiere zwei Handler-Funktionen f√ºr die Root-Felder unserer API:
  * Eine Handler-Funktion f√ºr `Query.stories` und f√ºr `Query.story(id: ID!)`
  * Eine Handler-Funktion f√ºr das `excerpt`-Feld am `Story`-Typen
* Die Handler-Funktionen kannst Du in der Klasse `nh.publy.backend.graphql.PublyGraphQLController` implementieren.
* Du kannst in der Controller-Klasse das `StoryRepository` verwenden.
  * Darin sind Methoden zum Ermitteln der Stories aus der Datenbank enthalten.
* Folgende Queries sollten danach funktionieren (in GraphiQL http://localhost:8090 ausf√ºhren!):
  * ```graphql
      query {
        stories {
          id title body

          writtenBy { id profileImage }
        }
      }
      ```
  * ```graphql
      query {
        story(storyId: 1) {
          id title body

          writtenBy { id profileImage }
        }
      }
      ```
* Eine m√∂gliche L√∂sung findest Du in `steps/10_handler_function`

---

## Exkurs: Listen mit GraphQL

* Typische Anforderungen: Sortieren, Filtern, Paginieren
* Wie k√∂nnten wir das Umsetzen? ü§î

---

## Handler-Funktionen an Objekt-Typen

* <!-- .element: class="demo" --> Demo: Excerpt-Feld hinzuf√ºgen
  * <!-- .element: class="demo" --> `SchemaMapping` Implementieren !

---

### Handler-Funktionen an Objekt-Typen

* Felder, die an einem Java-Objekt definiert sind, die von einer Handler-Funktion
  zur√ºckgeliefert werden, werden automatisch per Reflektion von Spring-GraphQL abgefragt
  * Voraussetzung: Name des Java-Felder/getter-Methode entspricht Namen am GraphQL Schema
  * Beispiel: `body`- und `writtenBy`-Feld an der `Story`-Entity
* Wenn es kein Feld am Java-Objekt gibt, oder es sich anders verh√§lt, als von der GraphQL
  API erwartet, m√ºssen wir auch daf√ºr Handler-Funktionen schreiben
* (Felder, die an Java Objekten existieren, aber nicht in der GraphQL API k√∂nnen nie vom 
  Client abgefragt werden.)

---

### SchemaMapping

* Die Funktion wird dann mit `@SchemaMapping` annotiert
  * Name muss dem Namen des Feldes in der API entsprechen
  * Parameter bestimmt das `Source`-Objekt, auf dem das Feld ermittelt werden soll
  * Das Source-Objekt stammt aus einem vorherigen DataFetcher

* ```java
  @Controller
  class GraphQLController {
    @SchemaMapping
    public String excerpt(Story source, @Argument int maxLength) {
      return source.getBody().substring(0, maxLength);
    }
  }
  ```

* Wenn die als Parameter √ºbergebene Klasse nicht so hei√üt, wie im GraphQL Schema,
  kann mit `typename` der GraphQL-Typ explizit gesetzt werden

* ```java
  @SchemaMapping(typeName="Story")
  public String excerpt(StoryDto source) {
    // ...
  }
  ```

* `@QueryMapping`, `@SubscriptionMapping` und `@MutationMapping` sind nur Aliase f√ºr
  * `@SchemaMapping(typeName="Query")`
  * `@SchemaMapping(typeName="Mutation")`
  * `@SchemaMapping(typeName="Subscription")`

  
---

## Asynchrone Handler-Funktionen

* <!-- .element: class="demo" --> Instrumentation hinzuf√ºgen
  * <!-- .element: class="demo" --> excerpt-Feld slowdown aktivieren
  * <!-- .element: class="demo" --> stories abfragen und Report auswerten
  * <!-- .element: class="demo" --> CompletableFuture


---

### Asynchrone Handler-Funktionen

* Handler-Funktionen werden grunds√§tzlich nacheinander ausgef√ºhrt 
* Handler-Funktionen k√∂nnen aber `CompletableFuture`, `Flux` oder `Mono`-Objekte zur√ºckliefern
  * `Flowable`-Objekte aus rxjava k√∂nnen mit `Flux.from` bzw. `Mono.from` konvertiert werden
* Dann werden mehrere Handler-Funktionen parallel ausgef√ºhrt

* ```java fragment
  @Service
  public class DomainService {
    @Async
    CompletableFuture<String> determineExcerpt(Story story, int maxLenght) {
      // long running task...
    }
  }

  @Controller
  public class GraphQLController {
    @Autowired DomainService domainService;

    @SchemaMapping
    public CompletableFuture<String> excerpt(Story story, @Argument int maxLength) {
      return domainService.determineExcerpt(story, maxLength); // asynchron bzw. reaktiv
    }
  }
  ```

---

### √úbung: Zugriff auf externen Service

* Wir erweitern den Member-Typen um das User-Objekt:

* ```graphql
  type User {
    id: ID!
    name: String!
    email: String!
  }

  type Member {
    # ...
    user: User
  }
  ```
* Die `Member`-Klasse hat aber keine Referenz auf den User (nur dessen Id)
* ```java
  @Entity
  public class Member {
    // ...
    @NotNull
    private String userId;

    public String getUserId() { return this.userId };
  }
  ```
* Der User kommt aus dem `UserService` (externer Micro-Service)


---

### √úbung: Schema-Mapping 

* Erg√§nze das Schema
  * Neuer Type `User`, Felder: `id` (ID), `name` (String) und `email` (String). Alle non-nullable. 
  * Erweiter den `Member`-Typen um das Feld `user` (Type: `User`, nullable).
* F√ºhre den untenstehenden Query aus. Was kommt f√ºr `user` zur√ºck und warum?  
* Implementiere die Schema-Mapping-Funktion f√ºr das Feld
  * Die Schema-Mapping-Funktion soll asynchron funktionieren
  * Der `UserService` ist bereits implementiert
* Der folgende Query sollte dann einen User zur√ºckliefern:
* ```graphql
  query {
    story(storyId: 1) {
      id 
      writtenBy {
        id

        # Hier sollten nun Daten kommen:
        user {
          id name email
        }

      }
    }
  }
  ```

* Eine m√∂gliche L√∂sung findest Du in `steps/15_schema-mapping`

---

## Mutation und Subscriptions

* Funktionieren analog zum `QueryMapping` nur f√ºr den Mutation- und Subscription-Type
* Bei Mutations d√ºrfen wir Daten ver√§ndern, ansonsten v√∂llig identisch zu `QueryMapping`
* Bei Subscriptions werden die Daten erst zum Server geschickt, nachdem sie erzeugt wurde
  * Etwas tricktreich, deswegen etwas sp√§ter

---

### Interaktiv: eine addPerson-Mutation

* <!-- .element: class="demo" --> AddPersonMutation, die eine Person mit firstName und lastName hinzuf√ºgt
  * <!-- .element: class="demo" --> Material dazu in `material/Person.txt`
  * <!-- .element: class="demo" --> Wie sieht das Schema aus?
  * <!-- .element: class="demo" --> Wie sieht die Java Implementierung f√ºr `input` aus?
  * <!-- .element: class="demo" --> Wie sieht die Java Implementierung f√ºr R√ºckgabewert aus?

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen

* Eine Story hat mehrere Kommentare:
* ```graphql
  type Comment {
      id: ID!

      story: Story!
      writtenBy: Member!
      content: String!
  }

  type Story {
    # ...
    comments: [Comment!]!
  }
  ```
* ü§î wie k√∂nnte eine Mutation aussehen, mit der ein Kommentar hinzugef√ºgt wird

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen

* Eingabe-Parameter werden mit einem `input-Type ausgedr√ºckt, der alle notwendigen Informationen entgegen nimmt
* ```graphql
  input AddCommentInput {
      storyId: ID!
      memberId: ID!
      content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
  ```
* ü§î Ist der R√ºckgabe-Typ hier so gut?
  * Was k√∂nnte problematisch sein oder werden?

---

### API Design von Mutations

* Wie ihr die Mutation designed ist nat√ºrlich Euch √ºberlassen, es gibt aber Best-Practices:
  * Anstatt n einzelne Argumente zu verwenden, **ein** Input-Objekt
    * Das Objekt hei√üt immer wie die Mutation mit `Input` am Ende
    * Das Argument hei√üt _immer_ `input`
  * Der R√ºckgabe-Typ sollte ebenfalls ein eigenes Objekt sein
    * Es hei√üt wie die Mutation mit `Payload` am Ende
    * Dieses Objekt enth√§lt dann das erzeugte neue Objekt
    * Ihr k√∂nnt sp√§ter diesen Typen um weitere Informationen, etwa zu Fehlern erweitern
      * Dazu sp√§ter mehr
* Dadurch ist die API einheitlich und man findet sich schnell zurecht
* Diese Regeln k√∂nntet ihr grunds√§tzlich auch f√ºr Queries und Subscriptions verwenden

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen
<!-- .slide: class="left" -->
* Fertige Mutation
* ```graphql
  input AddCommentInput {
      storyId: ID!
      memberId: ID!
      content: String!
  }

  type AddCommentPayload {
    newComment: Comment!
  }

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentPayload!
  }
  ```
---

### √úbung: addComment Mutation implementieren
#### Teil 1: Schema erweitern
* Erg√§nze das Schema um den `Comment`-Type und die `addComment` Mutation
  * `Comment`-Type soll die Felder haben: `id` (`ID`), `story`, `member` und `content` (`String`)
    * Alle Felder Pflicht (non-nullable)
  * Der `Story`-Type soll eine Feld `comments` bekommen, das eine Liste von `Comment`-Objekten zur√ºckliefert
  * Der folgende Query sollte nun funktionieren und einen Kommentar zur√ºckliefern:
    * ```graphql
      query {
        story(storyId:"2") {
          comments { id content }
        }
      }
    ```
  * Die `addComment`-Mutation soll ein `input`-Argument haben, das ein Objekt ist, das `storyId`, `memberId` (jeweils `ID!`)
            und `content` (`String!`) enth√§lt
  * Der R√ºckgabewert soll `AddCommentPayload` hei√üen, mit einem Feld `newComment`, das den neuen Kommentar enth√§lt
---

### √úbung: addComment Mutation implementieren
#### Teil 2: Implementieren in Java
  * Erweitere den `PublyGraphQLController` um die `MutationMapping`-Funktion
    * Baue dir jeweils eine Java-Klasse f√ºr das `input`-Argument und den R√ºckgabetyp
      * Wichtig: die ben√∂tigen jeweils einen Constructor, in den alle Daten √ºbergeben werden k√∂nnen (Argumente so benennen wie in GraphQL!)
    * Du kannst dir √ºber den `PublyGraphQLController`-Konstruktor den fertigen `PublyDomainService` √ºbergeben lassen
      * Daran gibt es eine Methode `addComment`, der einen Kommentar in der DB speichert
      * Ruf diese Methode auf und gib das Ergebnis an GraphQL zur√ºck
  * Danach sollte folgende Mutation funktionieren:
    * ```graphql
      mutation {
        addComment(input:{
          storyId:1, memberId:1, content: "tolle story!"
        }) {
        newComment {id content}
        }
    }
    ```


* Eine m√∂gliche L√∂sung findest Du in `steps/17_mutations`
---
### Subscriptions

* Subscriptions liefern einen Strom von Daten
* Eine Subscription kann Argumente entgegennehmen, wie Query und Mutation auch
* Der R√ºckgabewert in Java muss ein [Reactive Streams](https://www.reactive-streams.org/) `Publisher`-Objekt sein:
  * `Flux`- (oder `Mono`)-Objekt aus [Project Reactor](https://projectreactor.io/) (h√§ufig in Spring verwendet)
  * `Flowable` aus [RxJava](https://github.com/ReactiveX/RxJava)
---

### Interaktiv: Eine Subscription
* <!-- .element: class="demo" --> onNewNumber liefert Zahlen zur√ºck
  * <!-- .element: class="demo" --> (DemoNumberPublisher)
  * <!-- .element: class="demo" --> Wie sieht das Schema aus?
  * <!-- .element: class="demo" --> Wie k√∂nnen wir die Zahlen filtern, so dass z.B. nur gerade oder ungerade Zahlen kommen?
---

### √úbung: Eine Subscription f√ºr neue Kommentare
#### Baue eine Subscription, die ein `OnNewCommentEvent` mit einem neuen Kommentar f√ºr   eine ausgew√§hlte Story zur√ºckliefert
* Erweiter das Schema:
  * Die Subscription soll die `storyId` als Argument haben
  * Das `OnNewCommentEvent` soll ein Feld `newComment` mit dem neuen Kommentar (`Comment`) haben
* Implementiere die `SubscriptionMapping`-Funktion
  * Am `PublyDomainService` gibt es eine Methode, `getOnNewCommentEventPublisher`, die ein `Flowable`
            zur√ºckliefert, dass neue Kommentare publiziert
* Um zu testen, kannst Du den `DemoCommentGenerator` verwenden
  * Der erzeugt jede Sekunde einen neuen Kommentar f√ºr die Story `1`
  * Einschalten mit `publy.dummyContentGenerator.enable-auto=true` in der `application.properties`-Datei
* Danach sollte folgende Subscription funktionieren
* ```graphql
  subscription {
    onNewComment(storyId:1) {
      newComment {
        id content
        story { id title }
      }
    }
  }
```
* M√∂gliche L√∂sung in `steps/18_subscriptions`
---

## Optimierungen

---

### Ein einfacher Query...

* ü§î Was passiert, wenn wir folgenden Query ausf√ºhren:
* ```graphql
  query {
    stories {
      writtenBy { user { id email } }
    }
  }
  ```
* Wir haben sehr viele einzelne Calls zum Micro-Service üò®
* Wir haben doppelte Aufrufe zum Micro-Service üò± üò±

---

### Problem

<img src="images/dataloader-01.png" />

---

### DataLoder

* Ein `DataLoader` "verz√∂gert" das Laden von Daten

* <img src="images/dataloader-02.png" />

---

### DataLoader

* Ein `DataLoader` "verz√∂gert" das Laden von Daten
* In einem DataFetcher/Handler-Funktion √ºbergibst Du an einen DataLoader eine ID o.√§.
* Der DataLoader sammelt die IDs ein
* Wenn alle IDs eingesammelt wurden, wird die Implementierung des DataLoaders aufgerufen
* In der Implementierung bekommst Du alle IDs √ºbergeben und kannst einen optimierten Call machen
  * Zum Beispiel Zusammenfassung in SQL-Statements (`where ID in ...`)
* DataLoader sind ein allgemeines GraphQL-Konzept
  * Nicht in der Spec, aber de-facto Standard
* Java-Implementierung kommt aus dem [java-dataloader](https://github.com/graphql-java/java-dataloader)-Project
  * Wie bei `graphql-java` abstrahiert Spring for GraphQL davon
---

### Verwenden vom DataLoader

* Den DataLoader kannst Du dir in deine Handler-Funktionen √ºbergeben lassen
* Es handelt sich dabei um ein Interface mit zwei Typ-Parametern:
  * `Key`: Typ des Keys, den Du beim Verwenden an den DataLoader √ºbergeben willst
  * `Value`: Typ des Java-Objekts, das der DataLoader f√ºr einen Key zur√ºckliefert
* Die Handler-Funktion *muss* dann ein `CompletableFuture` zur√ºckliefern
* ```java
  public CompletableFuture<User> user(Member member, DataLoader<String, User> userLoader) {
    String userId = member.getUserId();  // userId ist in DB gespeichert

    return userLoader.load(userId); // Laden des Users wird verz√∂gert
  }
  ```

---


### Implementierung und Registrieren vom DataLoader

* Es gibt mehrere Wege
* In der `BatchLoaderRegistry` gibt es Hilfsfunktionen
* Die `BatchLoaderRegistry` steht als Spring Bean zur Verf√ºgung
* Mit `forTypePair` registrierst Du einen BatchLoader f√ºr ein Key-Value-Paar
* Die Methode erwartet eine Callback-Funktion:
  *  zwei Parameter: die Liste mit den Keys und das `BatchLoaderEnvironment`
  *  R√ºckgabe: die Liste mit den geladenen Objekten als [Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)
* ```java
  public PublyGraphQLController(/* ... */, BatchLoaderRegistry registry) {

    registry.forTypePair(String.class, User.class).registerBatchLoader(

      (List<String> keys, BatchLoaderEnvironment env) -> {
        // hier zum Beispiel DB-Aufruf oder REST-Aufruf
        // findUsers liefert Flux<User> zur√ºck.
        return userService.findUsers(keys);
      }
    );

  }
  ```
* Jeder Key wird nur einmal in die Liste eingef√ºgt, du bekommst also keine doppelten Keys
  * Selbst wenn Du also nicht _alle_ Objekte  mit _einem_ Request laden/ermitteln kannst,
    verhinderst Du immerhin doppeltes Laden
* Wichtig! Die Funktion muss die Objekte in derselben Reihenfolge zur√ºckliefern,
  in der die Keys √ºbergeben wurden.
  * Konnte f√ºr einen Key kein Objekt ermittelt werden, muss an der Stelle `null`
  zur√ºckgegeben werden

---

### MappedBatchLoader

* Der BatchLoader liefert eine _Liste_ von Objekten zur√ºck
* Die enthaltenen Objekte m√ºssen in derselben Menge und Reihenfolge wie die Keys zur√ºckgeliefert werden.
* Alternativ kann ein `MappedBatchLoader` verwendet werden, der ein [Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)-Objekt mit einer Map zur√ºckliefert
* Die Map enth√§lt dann Key-Value-Paare mit einem gelesenen Objekt jeweils f√ºr einen Key. Objekte, die nicht gefunden
  wurden werdenauch nicht in die Map aufgenommen.
* ```java
  public PublyGraphQLController(/*... */, BatchLoaderRegistry registry) {

    registry.forTypePair(String.class, User.class).registerMappedBatchLoader(

      (List<String> keys, BatchLoaderEnvironment env) -> {
        // zur√ºckgeben: Mono<Map<String, User>>
      }

    );
  }
  ```


---

### BatchMapping

* In einfachen F√§llen kann der `MappedBatchLoader` mit einer BatchMapping-Funktion implementiert werden
* Das ist eine Handler-Funktion, der automatisch eine Liste von Objekten √ºbergeben wird (zum Beispiel Liste von `Member`-Objekten)
* Die Handler-Funktion liefert dann entweder ein `Mono` mit einer `Map` oder ein `Flux` mit Objekten zur√ºck (wie vorher gesehen).
* Achtung! Darauf achten, dass `equals` und `hashCode`-Methoden in den Objekten, die als Keys verwendet werden, korrekt implementiert sind!
* ```java
  @Controller
  public class PublyGraphQLController {

    @BatchMapping
    public Flux<User> user(List<Member> member) {
      List<String> keys = member.stream().map(Member::getUserId).collect(Collectors.toList());

      return userService.findUsers(keys);
    }

    // -- oder: --

    @BatchMapping
    public Mono<Map<Member, User>> user(List<Member> member) {
      // ...
    }


    // BatchLoaderRegistry und SchemaMapping f√ºr User-Feld entfallen jetzt
  }
  ```

---

### Optimierung 2

* Ein Query...
  * ```graphql
    query {
      story(storyId: 1) {
        title
        body
      }
    }
  ```
* Ein anderer Query...
  * ```graphql
    query {
      story(storyId: 1) {
        title
        body
        comments { id content }
      }
    }
  ```
* ü§î Wie generieren wir optimale Datenbank-Zugriffe
  * Je nach Query mit oder ohne Comments?

---

### DataFetchingFieldSelectionSet

* Das `DataFetchingFieldSelectionSet` aus `graphql-java` enth√§lt eine Liste aller Felder, die im aktuellen Query unterhalb des Feldes einer Handler-Funktion abgefragt sind
* Das `DataFetchingFieldSelectionSet` kannst Du an deine Handler-Funktionen √ºbergeben lassen.
* Mit `contains` kannst Du mit einem Pattern fragen, ob bestimmte Felder im Query vorhanden sind
* Hiermit kannst Du weitere Optimierungen der Query-Verarbeitung vornehmen, zum Beispiel optimale
  SQL-Queries generieren
* ```java
  @QueryMapping
  List<Story> stories(DataFetchingFieldSelectionSet selectionSet) {

    if (s.contains("comments/**") ) {
      // SQL Statement mit JOIN auf Comment-Tabelle
      return ...;
    }

    // SQL Statement nur mit Stories
    return ...;

  }
  ```

---
### √úbung: DataLoader
#### Implementiere den DataLoader zum Laden des Users f√ºr einen Member aus dem User-Microservice

* <!-- .element: class="small" --> Stelle die Implementierung der `SchemaMapping`-Funktion von `user` f√ºr den `Member`-Typen auf den DataLoader um
  * Als neuen, zweiten Parameter ben√∂tigt die Methode einen DataLoader, der f√ºr die User-Keys die User laden kann.
  * Denk dran, dass Du den R√ºckgabetyp der Funktion auch anpassen musst!
* Erweitere den Konstruktur von `PublyGraphQLController` und f√ºge als neuen Parameter die `BatchLoaderRegistry` hinzu
* Registriere an der `BatchLoaderRegistry` einen BatchLoader, der f√ºr die Keys der User die entsprechenden User laden kann
  * Zum Laden der User kannst Du wieder die Klasse `UserService` verwenden
* F√ºhre folgenden Query aus. Wieviele `User` sind im Ergebnis vorhanden? Wieviele User(-Ids) werden im BatchLoader geladen?
* ```graphql
  query {
    stories {
      writtenBy { user { id name } }
      comments { writtenBy { user { id name } } }
    }
  }
  ```
* Eine L√∂sung findest Du in `steps/20_dataloader`
* Optional: kannst Du die Funktion auf eine `@BatchMapping`-Funktion umstellen?
  * Dann brauchst Du die `BatchLoaderRegistry` nicht mehr
  * Eine L√∂sung findest Du in `steps/25_batchmapping`

---


## Fehlerbehandlung

* <!-- .element: class="demo" --> Beispiel: Bean Validation mit `addPerson`-Mutation
  * <!-- .element: class="demo" --> @Size und @Valid hinzuf√ºgen
  * <!-- .element: class="demo" --> Errors-Objekt beschreiben
  * <!-- .element: class="demo" --> Was k√∂nnen wir besser machen: Optionen f√ºr Fehlerbehandlung durchspielen

---

### Fehlerbehandlung

* Fehler, die nicht in einer Handler-Funktion verarbeitet werden, werden im `errors`-Feld zur√ºckgeliefert:
* ```json
  {
    "errors": [
      {
        "message": "addComment.input.content: Gr√∂√üe muss zwischen 5 und 2147483647 sein",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "INTERNAL_ERROR"
        }
      }
    ]
  }
  ```
* ```json
  {
    "errors": [
      {
        "message": "Unauthorized",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "UNAUTHORIZED"
        }
      }
    ]
  }
  ```

---

### Fehlerbehandlung

* Das `errors`-Objekt ist nur eingeschr√§nkt spezifiziert:
  * `message`: Fehlermeldung
  * `locations`: Auf welche Code-Stelle im Query bezieht sich der Fehler (wenn vorhanden)
  * `path`: Pfad zum Feld, das den Fehler verursacht hat (wenn vorhanden)
  * `extensions`: Propriet√§re Erweiterungen (`classification` kommt von Spring for GraphQL)
  * Keines dieser Felder ist im Schema beschrieben!
* `errors`-Objekt nur f√ºr "Request Errors" verwenden, wenn der Query gar nicht
  oder nicht vern√ºnftig ausgef√ºhrt werden kann
* Sonst lieber "fachliche" Fehler-Objekte zur√ºckliefern
  * Das ist insbesondere bei Mutations sinnvoll, da hier Fehler nicht unwahrscheinlich sind
  * Auch f√ºr andere Felder √ºberlegen, um API abw√§rtskompatibel zu halten

---

### Explizite R√ºckgabetypen

* Beispiel 1: **Query-Ergebnisse**
* ```graphql
  type Query {
    stories: [Story!]!
  }
  ```
* Was machen wir, wenn wir dem Ergebnis weitere Informationen hinzuf√ºgen wollen, z.B. wie viele Stories gibt es eigentlich?
* √Ñnderung am R√ºckgabetyp w√§re hier nicht abw√§rtskompatibel! üò¢
* ```graphql
  type StoriesPayload {
    stories: [Story!]!

    maxStories: Int!
  }

  type Query {
    stories: [Story!]!
  }
  ```
---

### Explizite R√ºckgabetypen

* Beispiel 2: **Behandlung von Fehlern**
* Hier k√∂nnen wir keine Informationen hinterlegen, warum das Anlegen eines Kommentars m√∂glicherweise nicht geklappt hat:
  * ```graphql
    type Mutation {
      addComment: [Comment!]!
    }
    ```
* Mit einem eigenen R√ºckgabe-Objekt k√∂nnen wir weitere Informationen hinzuf√ºgen:
  * ```graphql
    type AddCommentPayload {
      newComment: Comment
      errorMessage: String
    }

    type Mutation {
      addComment: AddCommentPayload!
    }
    ```
* Dieses Objekt k√∂nnen wir jederzeit erweitern, ohne das Clients angepasst werden m√ºssen.
---

### Explizite R√ºckgabetypen
* Fehler- und nicht-Fehlerfall k√∂nnen mit jeweils eigenen Typen ausgedr√ºckt werden.
* Zusammengefasst werden sie in einem `union`-Typen:
  * ```graphql
    type AddCommentSuccessPayload { newComment: Comment! }
    type AddCommentFailedPayload { errorMsg: String! }
    union AddCommentPayload = AddCommentSuccessPayload | AddCommentFailedPayload

    type Mutation {
      addComment(inpit: AddCommentInput!): AddCommentPayload!
    }
    ```
* Der Server liefert je nach Situationen einen der beiden Typen zur√ºck.
  * ```graphql
    mutation {
      addComment(input: {storyId: 1, memberId: 1, content: "Toll"}) {
        ... on AddCommentSuccessPayload {
          newComment { id content }
        }
        ... on AddCommentFailedPayload { errorMsg }
      }
    }
  ```
  * Achtung! Umstellung von type- auf union-Type im R√ºckgabewert ist nicht abw√§rtskompatibel!

---
### √úbung: Union Types
#### Stelle die `addComment`-Mutation auf einen Union-Type um
* Passe das Schema an:
  * F√ºge den `AddCommentSuccessPayload` und `AddCommentFailedPayload` Typen hinzu
    * Bennene `AddCommentPayload in `AddCommentSuccessPayload` um
    * `AddCommentFailedPayload` soll ein `String!` Feld `errorMsg` haben
  * Definiere den `union`-Typen `AddCommentPayload` der aus den beiden Typen besteht
* Passe die Implementierung der `addComment`-Mutation an
  * Deinen bestehenden Java-Typen f√ºr `AddCommentPayload` kannst Du in `AddCommentSuccessPayload` umbennen
  * Du brauchst einen neuen Java-Typen f√ºr `AddCommentFailedPayload`
  * Wenn beim Aufruf des `PublyDomainService` eine Exception fliegt, gib `AddCommentFailedPayload` zur√ºck mit einer Fehlermeldung
  * Sonst gib den neuen Kommentar in `AddCommentSuccessPayload` zur√ºck
* F√ºhre `addComment` aus und frag den neuen Kommentar bzw. die `errorMsg` ab
  * Um den Fehlerfall zu testen, kannst Du einen Kommentar speichern, der k√ºrzer als f√ºnf Zeichen ist.
* M√∂gliche L√∂sung: `steps/30_error_handling`
---
## Security

* Wie √ºblich Spring Security verwenden
* ü§î√úberlegung: wo wird GraphQL API abgesichert?
  * /graphql-Endpunkt absichern
  * und/oder einzelne Handler-Funktionen mit `@PreAuthorize` absichern
  * und/oder Domain-Layer absichern mit `@PreAuthorize` absichern

---

### Beispiel: Security

* <!-- .element: class="demo" --> AddCommentMutation
  * <!-- .element: class="demo" --> AuthenticationPrincipal f√ºr Member
  * <!-- .element: class="demo" --> PreAuthorize

---

### Handler-Funktionen mit Security

* Handler-Funktionen k√∂nnen mit `@AuthenticationPrincipal` sich den aktuellen Principal √ºbergeben lassen

* ```java
  @MutationMapping
  @PreAuthorize("hasRole('USER')")
  public AddCommentPayload addComment(@Argument AddCommentInput input, @AuthenticationPrincipal User user) {

    Long memberId = publyDomainService.getMemberForUser(user);

    // ...
    Comment newComment = publyDomainService.addComment(
      input.getStoryId(),
      memberId,
      input.getContent()
    );

    return ...;
  }
  ```

---
# GraphQL APIs testen

---

### Test

* Zum Testen deiner Anwendung gibt es einen `@GraphQLTest`.
* Dieser erzeugt u.a. Controller-Klassen und RuntimeWirings (also GraphQL Infrastruktur)
* In diesem Test kann ein `GraphQlTester` verwendet werden, um GraphQL Queries auszuf√ºhren
* Das Ergebnis des Queries kann dann validiert werden
  * Mit JSON-Path ausdr√ºcken kann auf Teile des Ergebnisses zugegriffen werden
  * Die Teile k√∂nnen in unterschiedliche Formate konvertiert werden

* ```java fragment

  @GraphQlTest
  public class PublyGraphQLControllerTest {

    // ausgelassen: Mocks konfigurieren, z.B. f√ºr Repositories mit @MockBean

    @Autowired
    GraphQlTester graphQlTester;

    private final String query = "query { ping }";

    @Test
    void pingReturnsPong() {
      // Query ausf√ºhren
      GraphQlTester.Response response = graphQlTester.document(query)
        .execute();

      // Ergebnis validieren
      response
        .path("ping").entity(String.class).isEqualTo("pong");

    }
  ```

---

### GraphQlTester

* Der Query kann entweder direkt als String √ºbergeben werden (wie gesehen)
* oder in einer Datei abgelegt werden (`xyz.graphql`), die im Klassenpfad sein muss

* ```java
  @Test
  void pingReturnsPong() {

    graphQlTester.document("query { ping } "); // ...

    graphQlTester.documentName("ping-test-query"); // erwartet ping-test-query.graphql im Klassenpfad
  }

  ```

---

### Der WebGraphQlTester

* Mit dem `WebGraphQlTester` k√∂nnen GraphQL Requests √ºber HTTP gemacht werden
* An einen laufenden Server oder in-place
* Dazu kann ein gewohnten `@SpringBootTest` geschrieben werden
* Die Testklasse muss au√üerdem mit `@AutoConfigureHttpGraphQlTester` annotiert werden
* API ansonsten wie GraphQlTester

* ```java
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  @AutoConfigureHttpGraphQlTester
  public class PublyGraphQLControllerWebTest {
    @Autowired
    private WebGraphQlTester webGraphQlTester;

    @Test
    void pingReturnsPong() {
      // Query ausf√ºhren
      webGraphQlTester.document("query { ping }")
        .execute()
        .validate(/* ... */);
    }
  }
  ```

---

### WebGraphQlTester

* Der injizierte `WebGraphQlTester` ist fertig konfiguriert
* Kann aber pro Request angepasst werden, z.B. um HTTP Header zu setzen
* dazu muss eine neue Instanz mit `mutate` erzeugt werden

* ```java
  graphQlTester
      .mutate() // erzeugt neue Instant, die konfiguriert werden kann
      .header("Authorization", "Bearer user-mock-token")
      .build()
      .document(query) /* konfigurierte Instanz verwenden... */
  ```

---

### √úbung: Tests

_Schreibe einen Test f√ºr unsere GraphQL-API_

* <!-- .element: class="small" --> Der Test kann z.B. eine einzelne Story mit einer ID abfragen, und sicherstellen, dass die abgefragten Felder korrekt in der Antwort enthalten sind:
  * ```graphql

    query {
      story(storyId: 1) {
        title
        body

        member { id }
      }
    }
    ```

* Verwende den `@GraphlTest`
  * Der Controller wird dabei erzeugt, aber die Repositories m√ºssen gemockt werden
* Im Workspace findest Du im `test`-Verzeichnis eine Klasse `AbstractPublyGraphQLTest`, die Du als Basis verwenden kannst
  * Darin sind schon die Mock-Beans konfiguriert
  * Es gibt Hilfsfunktionen zum Aufsetzen der Mockdaten (`given_`), die Du je nach Testfall aufrufen kannst
  * Du kannst nat√ºrlich auch eigene Mocks f√ºr andere Tests schreiben
* Leite deine Testklasse davon ab
  * Du musst deine Testklasse mit `@GraphQlTest` annotieren
* Bespiele findest Du in `steps/50_test`



             </textarea
          >
        </section>

        <!-- ============================= GRAPHQL ANFANG =================================================================== -->
        <section id="t-apollo-react">
          <h3>Teil 3</h3>
          <h1>GraphQL</h1>
          <h2>Clients mit Apollo React</h2>
        </section>

        <section data-markdown="">
          <textarea data-template>
### Vorbereitung: Workspace starten

* **Backend**
*   `publy-backend/src`-Verzeichnis *l√∂schen* (ggf. vorher Eure √Ñnderungen sichern)
  * `steps/90_app/src`-Verzeichnis nach `publy-backend` kopieren
  * `publy-userservice` starten (Klasse: `nh.graphql.publy.userservice.UserserviceApplication`)
  * `publy-backend` starten (Klasse: `nh.publy.backend.PublyApplication`)
  * Diese beiden Prozesse k√∂nnen im folgenden einfach immer weiter laufen. Wir machen daran keine √Ñnderungen mehr.
* **Frontend** (Verzeichnis: `publy-frontend`)
  * Verzeichnis `publy-frontend/src` l√∂schen
  * `frontend-steps/01_initial_uebungen/src` nach `publy-frontend/src` kopieren
  * Im Verzeichnis `publy-frontend` Packages installieren und starten:
    * `pnpm install`
    * `pnpm start`
  * Frontend sollte dann auf http://localhost:3000 laufen
    * Header und "Read more"-Button sollten angezeigt werden
* Wenn fertig, bitte in Zoom "Hand heben" üôã
  </textarea
          >
        </section>

        <section>
          <h3>Apollo Client</h3>
          <p>
            <a href="https://www.apollographql.com/docs/react/"
              >https://www.apollographql.com/docs/react/</a
            >
          </p>
          <p>React Hooks um mit GraphQL Services zu kommunizieren</p>
          <p>
            Stellt einen <b>globalen Cache</b> zur Verf√ºgung, um konsistente
            Daten in der ganzen Anwendung sicherzustellen
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo Client DevTools</h3>

          <p>Browser-Erweiterung, stellt z.B. den Inhalt des Caches dar</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/de/firefox/addon/apollo-developer-tools/"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Apollo Client

* Das `ApolloClient`-Objekt ist unter anderem f√ºr den Netzwerkverkehr, den Cache
            und Fehlerbehandlung zust√§ndig
* Der `ApolloClient` ist React-unabh√§ngig und kann auch mit anderen JavaScript-Frameworks
            verwendet werden.
* ```javascript
  import ApolloClient from "apollo-client";

  const client = new ApolloClient({
    link: new HttpLink({uri: "http://localhost:4000"}),
    cache: new InMemoryCache()
  }};
  ```

---

### Link

* Mit einem `Link` wird beschrieben, wie Apollo die HTTP-Requests zum Server machen soll
  * Man kann zum Beispiel eigene HTTP Header hinzuf√ºgen
  * Auch die Konfiguration f√ºr Websockets f√ºr Subscriptions erfolgt dar√ºber
* F√ºr verschiedene Aufgaben gibt es verschiedene `Link`-Implementierungen, die
  hintereinander ausgef√ºhrt werden k√∂nnen

---

### Link

* Beispiel: Header f√ºr Authentifizierung
* ```javascript
  const authLink = setContext((_, { headers }) => {
    // get the authentication token from local storage if it exists
    const token = localStorage.getItem("publy.token");
    if (!token) {
      return headers;
    }
    // return the headers to the context so httpLink can read them
    return {
      headers: {
        ...headers,
        Authorization: `Bearer ${token}`,
      },
    };
  });
  ```

---

### Subscriptions

* Um mit Subscriptions zu arbeiten, braucht man einen eigenen `Link`
  * "Regul√§re" Requests (f√ºr Queries und Mutations) m√ºssen an den HTTP-Endpunkt gehen
  * F√ºr Subscriptions m√ºssen die Requests √ºber das WS-Protokoll an den WS-Endpunkt gehen
* Es gibt einen eigenen Link daf√ºr: `GraphQLWsLink`
* ```javascript
  const wsLink = new GraphQLWsLink(
    createClient({
      url: "ws://localhost:8080",
    })
  );
  ```

---

### Subscriptions

* Mit einem _Splitter_ kann ausgew√§hlt werden, mit welchem `Link` ein Request an den Server gesendet werden soll
* Damit k√∂nnen Subscriptions mit dem eigenen Websocket-Link ausgef√ºhrt werden
* ```javascript
  const wsLink = ...;
  const httpLink = ...;

  const remoteLink = split(
    // split based on operation type
    ({ query }) => {
      const def = getMainDefinition(query);
      return (
        def.kind === "OperationDefinition" && def.operation === "subscription"
      );
    },
    wsLink,
    httpLink
  );
  ```

---

### Links

* Die Links werden beim erzeugen des Apollo Clients aneinander geh√§ngt
* ```javascript
  const client = new ApolloClient({
    link: ApolloLink.from([authLink, remoteLink]),
    cache: new InMemoryCache()
  });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo React Client</h3>
          <p>
            Die Komponenten bzw. die React-spezifische API des Apollo Clients,
            ben√∂tigt Zugriff auf den ApolloClient
          </p>
          <p>Das Client-Objekt muss der Anwendung bereitgestellt werden</p>
          <p>
            Dazu wird die <code>ApolloProvider</code>-Komponente verwendet, die
            allen darunterliegenden Komponenten Zugriff auf den ApolloClient
            erm√∂glicht:
          </p>

          <pre class="fragment"><code class="javascript">
import { ApolloProvider } from "@apollo/client";

const client = ...;

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(
    &lt;ApolloProvider client={client}>
      &lt;App />
    &lt;ApolloProvider>
  );
</code></pre>
          <p class="fragment">
            (Der Apollo Client verwendet intern die
            <a ref="https://reactjs.org/docs/context.html">React Context API</a
            >)
          </p>
        </section>
        <section>
          <h3>Apollo GraphQL Client in React</h3>
          <p>Live: workspace-graphql</p>
        </section>
        <section data-markdown="">
          <textarea data-template>
### GraphQL Operationen beschreiben

* GraphQL Operationen k√∂nnen inline oder in einer eigenen Datei beschrieben werden
* Inline: mit der `gql` [Tagged Template Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) direkt im Code
* Die `gql`-Funktion erzeugt ein **GraphQL Document Object**, das die geparste Operation enth√§lt
    * Dieses Objekt verwenden wir zum Ausf√ºhren der Operation
* ```javascript
  import { gql } from "@apollo/client";

  const PostListQuery = gql`
    query PostListQuery {
      posts {
        id
        title
        teaser(maxLength: 20)
        date
      }
    }
  `;
  ```
* Um die GraphQL-Operationen in einer eigenen Datei abzulegen und zu importieren, m√ºsst ihr [Euer Setup anpassen](https://create-react-app.dev/docs/loading-graphql-files/)
  * Wenn ihr mit dem [GraphQL Codegenerator](https://www.graphql-code-generator.com/) arbeitet, braucht ihr das _nicht_


---

### Verwenden des Apollo React Clients
* Apollo stellt f√ºr die drei GraphQL Operationstypen jeweils eigene
              Hooks zur Verf√ºgung:
  * [useQuery](https://www.apollographql.com/docs/react/data/queries/#usequery-api) bzw. [useLazyQuery](https://www.apollographql.com/docs/react/data/queries/#manual-execution-with-uselazyquery)
  * [useMutation](https://www.apollographql.com/docs/react/data/mutations/#usemutation-api)
  * [useSubscription](https://www.apollographql.com/docs/react/data/subscriptions/#usesubscription-api-reference)
* Die Hooks funktionieren alle √§hnlich:
  * Sie erwarten ein Dokument mit einer GraphQL Operation (Ergebnis von `gql`)
  * Verhalten kann mit weiteren Argumenten konfiguriert werden, z.B. Setzen von Variablen
  * Der R√ºckgabetyp ist ein Objekt mit Informationen √ºber den Request (loading, data, error). Bei
    `useMutation` kommt kommt au√üerdem eine Funktion zum Ausf√ºhren der Mutation zur√ºck

---

### useQuery: GraphQL Query ausf√ºhren
* Der `useQuery`-Hook f√ºhrt einen GraphQL aus:
* ```typescript
  const FeedPageQuery = gql`...`;
  function Feedpage() {
    const { loading, error, data } = useQuery(FeedPageQuery);

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return &lt;TeaserList story={data.stories} />;
  }
  ```
---

### useQuery - Lebenszyklus
* `useQuery`f√ºhrt den √ºbergebenen Query automatisch aus, sobald die Komponente _gemounted_ wurde
* Sobald der Request l√§uft, gibt die Funktion ein Objekt zur√ºck, in dem `loading` auf `true` gesetzt ist. Damit kannst Du z.B. einen Loading Indikator anzeigen
* Sobald die Antwort des Queries ankommt, wird deine Komponente erneut gerendert
  * Der useQuery-Hook gibt nun ein Objekt zur√ºck, in dem entweder <code>error</code> oder
              `data` gesetzt ist und `loading` nun `false` ist.
  * Du kannst die Informationen nutzen, um die Darstellung zu aktualisieren
  * Wenn der Request erfolgreich war, aktualisiert Apollo den globalen Cache mit den
              geladenen Daten
  * _Alle_ sichtbaren Komponenten, die (Teile der) geladenen Daten darstellen,
              werden automatisch aktualisiert

---

### useQuery: Variablen
* GraphQL Queries k√∂nnen Variablen enthalten
* Das (optionale) zweite Argument von `useQuery` ist ein Objekt mit Konfigurationsoptionen
* Mit diesem Argument kannst Du Variablen an deinen Query √ºbergeben
* ```graphql
  const STORY_PAGE_QUERY = gql`
    query StoryPageQuery($storyId: ID!) {
      story(storyId: $storyId) {
        id title createdAt
        body member { user { name } }
      }
    }
  `;
  ```
* ```graphql
  function StoryPage() {
    // Example: Receive storyId from URL params
    const { storyId } = useParams();

    const { loading, error, data } = useQuery(STORY_PAGE_QUERY,
      {
        variables: { storyId }
      }
    );
    // ...
  }
  ```
---
### Apollo Hooks mit TypeScript
* Die Apollo Hooks k√∂nnen mit Typ-Parametern typsicher gemacht werden.
* In der Regel k√∂nnen zwei Parameter angegeben werden:
  * `TData`: beschreibt, wie die gelesenen Daten aussehen (`data`-Knoten)
  * `TVariables`: beschreibt, ob/wie ben√∂tigte Variablen aussehen
* ```typescript
  const STORY_PAGE_QUERY = gql`...`;

  type StoryPageQuery = {
    id: String, title: String, body: string, member: { id: string, bio?: string } }
  }

  type StoryPageVariables = { storyId: string }

  function StoryPage({storyId}: {storyId: string}) {
    const result = useQuery<StoryPageQuery, StoryPageVariables>({
            variables: { storyId });

    result.data?.id; // OK
    result.data?.content; // ERROR content not in data
    // ...
  }
  ```
* Das `data`-Field in dem Ergebnis ist in TypeScript _immer_ optional, da es
  im Fehlerfall nicht gesendet wird!
* ```typescript
  const {data} = useQuery<...>();

  data.story.id; // ERROR: data might be undefined
  if (!data) {
    return <h1>No Data!</h1>;
  }
  data.story.id; // OK
  ```
---

### TypeScript Code generieren
* Das Project [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen) bietet Code Generatoren f√ºr eine Reihe von GraphQL Frameworks, u.a. Apollo/React
* Generiert werden k√∂nnen damit:
  * Typen f√ºr das Query-Ergebnis (`TData`)
  * Variablen (`TVariables`)
  * Typen f√ºr verwendete Fragmente
  * Fertige Hook-Funktionen

---
### Code Generator: Konfiguration
* Je nach Konfiguration sucht der Generator nach `.graphql`-Dateien mit Queries und/oder `gql`-Funktionen
* Die Typen werden in eine Datei (z.B. `generated.tsx`) geschrieben
* Der Generator braucht Zugriff auf das Schema (lokal oder remote)
* Der Generator kann im watch-Modus betrieben werden, dann wird automatisch neu generiert, wenn neue Queries geschrieben werden
* ```yml
  overwrite: true
  schema:
    # Lokales Schema, aber remote-Schema geht auch
    - "../publy-backend/src/main/resources/graphql/publy.graphqls"
  # In welchen Dateien soll nach GraphQL Queries gesucht werden?
  documents: "./src/**/{*.graphql,*.tsx}"
  # Was (und wohin) soll generiert werden:
  generates:
    src/generated/graphql.tsx:
      plugins:
        - "typescript"
        - "typescript-operations"
        - "typescript-react-apollo"
```
* Empfehlung: Code Generator auch im CI Build ausf√ºhren lassen!

---
### Code Generator
* _Empfehlung_: Typen und Hooks generieren lassen
* Die generierten Hooks sind "nur" Wrapper-Funktionen um `useQuery`, `useMutation`, ersparen
  aber das hinschreiben der Typ-Informationen und des Dokuments mit dem Query
* ```typescript
  function StoryPage({storyId}: {storyId: string}) {

    // useQuery:
    const { data } = useQuery<StoryPageQuery, StoryPageQueryVariables>(
            STORY_PAGE_QUERY, { variables: { storyId } });

    // generierter Hook:
    const { data } = useStoryPage({ variables: { storyId } });

    // data-Objekte in beiden F√§llen gleich
  ```
---
### Code Generator: Fragmente
* F√ºr verwendete Fragmente wird ein eigener TypeScript-Typ generiert, das kann praktisch
  sein, wenn man Typen f√ºr Teile eines Queries ben√∂tigt.
* Beispiel:
* ```graphql
  query { stories { member { user { id name } } } }
```
* Generierter Typ (konzeptionell):
* ```typescript
  type StoriesQuery = { stories: Array<{ member: { user: { id: string, name: string } } }> }
  ```
* Um nur den Typen f√ºr den User zu ermitteln (z.B. um in einer Komponente als Property zu verwenden),
 kann man schreiben:
* ```javascript
  type UserType = StoriesQuery["stories"][0]["member"]["user"]; // ü§Ø üò±
  ```
* Einfacher mit einem Fragment:
* ```graphql
  fragment UserFragment on User { id name }
  query { stories { member { user { ...UserFragment } } } }
  ```
* Nun wird ein `UserFragment`-Typ generiert:
* ```typescript
  type UserFragment = { id: string, name: string }; // üòä
  ```
---

### Refetch Funktion
* `useQuery` liefert eine **refetch**-Funktion, die Du verwenden kannst, um
            den Query erneut auszuf√ºhren (z.B. nach Klick auf einen "Aktualisieren"-Button)
* Bei Bedarf kannst Du der `refetch`-Funktion neue Variablen √ºbergeben
  * Zum Beispiel um eine weitere Seite eines Such-Ergebnisses zu laden
* ```javascript
  function StoryFeedPage() {
    const { loading, error, data, refetch } = useStoryFeedPageQuery();

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return <TeaserList stories={data.stories} onRefetch={refetch} />;
  }

  function TeaserList({stories, onRefetch}) {
    return <div>
      <button onClick={onRefetch}>Refresh</button>
      ...
    </div>
  }
  ```

---
### √úbung: Query ausf√ºhren

* Die `FeedPage` soll eine Liste von Stories ("Feed") anzeigen
* Erg√§nze in `src/FeedPage/Feedpage.tsx` den dazu notwendigen Code
* In der Datei findest Du TODOs mit weiteren Informationen
* Eine m√∂gliche L√∂sung findest Du in `steps-frontend/10-useQuery`

---

### useQuery: Caching
* Wenn deine Komponente erneut gerendert wird, wird dein Query
            **nicht erneut ausgef√ºhrt**, sofern Apollo das Ergebnis noch im Cache findet
* <!-- .element: class="demo" -->Netzwerk-Tab
---

### Der Apollo Cache
* Apollo _normalisiert_ die Daten bevor sie in den Cache gelegt werden:
* F√ºr jedes Objekt, das als Teil deines Queries geladen wurde (egal auf welchem Level),
            Apollo ermittelt den **typename** (`__typename`-Feld)
  * Das `__typename`-Feld wird daf√ºr automatisch allen Queries von Euch
            hinzugef√ºgt!
* F√ºr jedes Objekt extrahiert Apollo dessen `id`
  * Wenn das `id`-Feld eines Objektes nicht `id` hei√üt, muss das in der
            Konfiguration von Apollo gesetzt werden
  * **Empfehlung:** *Immer* das `id`-Feld in jedem Objekt in jedem Query
            abfragen!
* Achtung! Listen werden *nicht* aktualisiert, bzw. nicht erweitert/gek√ºrzt
---

### Der Apollo Cache: Aktualisierung
* Es gibt mehrere M√∂glichkeiten, den Cache zu aktualisieren:
  * [Fetch Policy](https://www.apollographql.com/docs/react/data/queries/#setting-a-fetch-policy)
  * [Refetch Function](https://www.apollographql.com/docs/react/data/queries/#refetching)
  * [Polling](https://www.apollographql.com/docs/react/data/queries/#polling)
  * F√ºr Paginierung von Listen mit der [Fetch more](https://www.apollographql.com/docs/react/pagination/core-api/#the-fetchmore-function)-Funktion
  * [Per Subscription](https://www.apollographql.com/docs/react/data/subscriptions/#subscribing-to-updates-for-a-query)
  * Nach einer Mutation direkt mit der [Cache API](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly)
---

### Fetch Policy
* Mit einer Fetch Policy kannst Du bei `useQuery` einstellen, wann dein Query
            erneut ausgef√ºhrt werden soll
  * **cache-first**: Wenn die angeforderten Daten bereits im Cache sind, werden sie aus
              dem Cache zur√ºckgegeben, sonst vom Backend geladen (Default)
  * **cache-and-network**: Falls vorhanden, Daten aus dem Cache zur√ºckgeben, aber in
              jedem Fall auch einen Backend-Request auszuf√ºhren, um ggf. aktualisierte Daten zu
              laden (Schnelle Darstellung, die ggf. kurze Zeit sp√§ter aktualisiert wird)
  * **network-only**: Immer Daten vom Backend laden (keine Daten vom Cache verwenden),
              aber mit dem Ergebnis den Cache aktualisieren
  * **no-cache**: Immer Daten vom Backend laden und auch nicht den Cache aktualisieren
  * **cache-only**: Nur Daten vom Cache verwenden. Wenn die Daten darin nicht gefunden
              werden, wird kein Ergebnis zur√ºckgeliefert
* <!-- .element: class="demo" --> Cache-Policy zeigen
---

### Fetch Policy: Beispiel
* ```javascript
  function StoryPage() {
    const { storyId } = useParams();

    const { loading, error, data } = useQuery(STORY_PAGE_QUERY,
      {
        variables: { storyId },
        fetchPolicy: "network-only"
      }
    );
    // ...
  }
  ```

### Polling
* Du kannst ein `pollInterval` (Zeit in ms) als Query Option angeben. Apollo
            f√ºhrt dann den Query dann in dem angegebenen Interval automatisch neu aus und aktualisiert den Cache mit den gelesenen Daten
* ```javascript
  function StoryFeedPage() {
  const { loading, error, data } = useQuery(STORY_FEED_QUERY,
    { pollInterval: 1500 }
  );

  // ...wie gesehen...
  }
  ```
---
### Aktualisieren von Listen
* Wenn neue Daten f√ºr eine Liste geladen werden (oder welche entfernt werden),
  wei√ü Apollo nicht, wie damit umzugehen ist
* Der Cache kann dann nicht automatisch aktualisiert werden
* Beispiel:
  * Zus√§tzliche Stories werden auf der FeedPage gelesen (n√§chste "page")
  * M√ºssen die gelesenen Stories am Anfang oder Ende der bestehenden Liste eingef√ºgt werden?
  * Sollen sie dort √ºberhaupt eingef√ºgt werden?
* Beispiel 2:
  * Ein Kommentar wird mit einer Mutation angelegt
  * In welche bestehenden Listen im Cache muss der Kommentar?

---
### Aktualisieren von Listen
* Grunds√§tzlich k√∂nnen Listen mit verschiedenen Strategien aktualisiert werden:
  * **fetch more**: Jemand klickt z.B. auf "Weitere Eintr√§ge laden"-Link
    * Beispiel: Liste von Stories in Feed-Page
  * **subscription**: Eine Subscription liefert neue Elemente, die (auch) in eine bestehende Liste eingef√ºgt werden
    * Beispiel: Neuer Kommentar in `StoryComments`
    * Diesen Fall sehen wir uns im Zusammenhang mit Mutations an
  * **update**: Nach einer Mutation, die ein neues Objekte erzeugt (oder l√∂scht), soll das Objekt
            in eine Liste hinzugef√ºgt (oder gel√∂scht) werden
    * Diesen Fall sehen wir uns im Zusammenhang mit Mutations an
* In jedem Fall m√ºssen wir dazu implementieren, *wie* die neuen Daten in die gecachten Listen kommen

---
### Aktualisieren von Listen: Pagination mit fetchMore
* Anwendungsfall:
  * es gibt eine Liste, durch die durchgebl√§ttert werden kann
  * die jeweils neu geladenen Objekte sollen der Liste auch im Cache hinzugef√ºgt werden
  * Vorteil: wenn Benutzer dann nochmal zur√ºckbl√§ttert, sind die Objekte schon da
* Dazu liefert `useQuery` eine weitere Funktion zur√ºck: `fetchMore`

* Diese Funktion akzeptiert im einfachsten Fall neue Query _Variablen_ und f√ºhrt den Query neu aus
* ```javascript
  function FeedPage() {
    const { loading, data, error, fetchMore } = useFeedPageQuery();

    // ...

    const handleFetchMore = () => {
      fetchMore({
        variables: {
          page: data.stories.page.pageNumber + 1, // fetch next page
        },
      });
    };

    return <div>
       {data.page.hasNext && <button onClick={handleFetchMore}>Next</button>}
       // ...
    </>
  }
  ```
* Die geladenen Daten landen aber nicht im Cache üò≠
* <!-- .element: class="demo" --> Cache im DevTools mit fetchMore
---

### Type Policy
* Mit einer **Type Policy** muss die Aktualisierung des Caches f√ºr ein Feld angepasst werden
  * Achtung 1: Das ist - je nach Schema, Query und Fachlichkeit - nicht trivial!
  * Achtung 2: TypeScript-Support an der Stelle nur eingeschr√§nkt!
* In der Cache-Konfiguration beim Erzeugen des Apollo Clients:
* ```javascript
  const apolloClient = new ApolloClient({
    // ...
    cache: new InMemoryCache({
      typePolicies: {
        Query: {
          fields: {
            stories: {
              keyArgs: false,
              merge(
                existing: StoryConnection | undefined | null,
                incoming: StoryConnection
              ) {
                if (!existing) { return incoming; }
                const merged = {
                  page: incoming.page,
                  stories: [...existing.stories, ...incoming.stories],
                };
                return merged;
              }  }  }  } }
            }),
        });
  ```
  * <!-- .element: class="demo" -->Der Cache in den Developer-Tools mit fetchMore-Funktion in FeedPage

---


### Apollo GraphQL: Mutations
<!-- .slide: class="left" -->

* Ausf√ºhren von Mutations ist √§hnlich wie das Ausf√ºhren eines Queries
* Hook: [useMutation](https://www.apollographql.com/docs/react/data/mutations/#executing-a-mutation)
* Der `useMutation` Hook gibt ein Array (Tuple) mit zwei Eintr√§gen zur√ºck:
  1. Eine Funktion zum Ausf√ºhren der Mutation (z.B. nach einer Benutzerinteraktion)
  2. Das Ergebnis-Objekt, das wir schon bei `useQuery` gesehen haben
            (zus√§tzlich: ein `called`-Property, das angibt, ob die Mutation bereits mind. einmal ausgef√ºhrt wurde)
* ```jsx
  const ADD_COMMENT_MUTATION = gql`...`;
  type AddCommentMutation = { newComment: ... };
  type AddCommentVariables = { input: ... };

  function CommentEditor() {
    const [mutate, { error, data, called }] = useMutation<AddCommentMutation, AddCommentVariables>
            (ADD_COMMENT_MUTATION);

    // oder generiert:
    const [mutate, { error, data, called }] = useAddCommentMutation();

    function addComment(commentInput) {
      // Verwendung von mutate hier Typsicher, da TS
      // das 'variables'-Objekt von useMutation kennt
      mutate({
          variables: { input: commentInput }
      });
    }

    const errorMessage = error ? ... : null;

    if (called && !errorMessage) {
      // Mutation has been executed and was successful
      return &lt;SuccessConfirmation />;
    }

    // Mutation hasn't been run or failed with an error
    return <form>
            <input name="comment" ... />
            {errorMessage && <p>Error: {errorMessage}</p>}
           </form>
  }
  ```
---

### Die mutate-Funktion

* Der `mutate`-Funktion k√∂nnen (fast) alle Argumente √ºbergeben werden, die
  auch an `useMutation` √ºbergeben werden k√∂nnen (insb. Variablen)
* Beim Aufruf der `mutate`-Funktion wird die Mutation ausgel√∂st und die Komponente
  wird mit neuen Ergebnissen (oder Fehlern) neu gerendert (wie bei `useQuery`)
* Die `mutate`-Funktion liefert ein Promise zur√ºck, das mit dem Ergebnis
  der Mutation (`data` oder `errors`) aufgel√∂st wird, sobald das Ergebnis da ist
* Damit kannst Du weitere Logik unmittelbar nach dem Abschluss der Mutation ausf√ºhren
* ```javascript
  function CommentEditor({onCommentSaved}) {
    const [mutate, { error, data, called }] = useAddCommentMutation();

    async function addComment(commentInput) {
      // Verwendung von mutate hier Typsicher, da TS
      // das 'variables'-Objekt von useMutation kennt
      const {data, error} = mutate({
          variables: { input: commentInput }
      });

      if (data) {
       // Alles OK, z.B. Redirect hier machen
       history.push("/...");
       // oder Callback von Oberkomponente aufrufen:
       onCommentSaved();
      }
    }

```
---

### √úbung: eine Mutation
* Die Logik zum Anlegen eines Kommentars implementieren
* Die Mutation (`AddCommentMutation`) ist schon fertig und der Code daf√ºr generiert
* In `CommentEditor` musst Du den Code vervollst√§ndigen, siehe dort f√ºr weitere Informationen
* Achtung: Der neue Kommentar wird (noch) nicht automatisch angezeigt, d.h. Du musst nach dem erfolgreichen speichern die Seite neu laden!
* M√∂gliche L√∂sung in `steps-frontend/20_useMutation`

---
### Nach einer Mutation... wird der Cache automatisch aktualisiert (eventuell)
* Wenn deine Mutation ein Objekt zur√ºckliefert, das sich bereits im Cache befindet, wird
            es dort aktualisiert
* Beispiel: Du *aktualisierst* eine existierende Story und das Ergebnis der
            Mutation enth√§lt irgendwo die aktualisierte Story (zumindest die aktualisierten Teile).
  * Voraussetzung: im Ergebnis kommt auch die `id` der Story vor
* ```javascript
  const UpdateStory = gql`
    mutation {
      updateStory(storyId: "S1", newTitle: "...", newBody: "...") {
          id
          title
          body
      }
    }
  ```
* In diesem Beispiel kann Apollo das Objekt <b>S1</b> im Cache automatisch aktualisieren
---
### Den Cache nach einer Mutation aktualisieren
* Mit [refetch Queries](https://www.apollographql.com/docs/react/data/mutations/#refetching-queries) kannst Du eine Liste von Queries angeben, die erneut ausgef√ºhrt werden, wenn
              eine Mutation erfolgreich war
* Mit der [update Function](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly) kannst Du den Cache direkt per API manipulieren, sobald deine Mutation erfolgreich
              war
---

### Die Apollo Cache API
* Du kannst den Query auslesen (mit einem GraphQL Query!)
* Du kannst den Cache direkt modifizieren
---

### Beispiel: Den Cache aktualisieren
* Du kannst die `update`-Function bei `useMutation` angeben:
* Diese Funktion wird nach dem Ausf√ºhren der Mutation von Apollo aufgerufen
* Die Funktion bekommt das Mutation-Ergebnis sowie den aktuellen Cache von Apollo
            √ºbergeben
* Mit der Cache API kannst Du das neue Objekt in den Cache an allen erforderlichen Stellen einf√ºgen
* ```javascript
  const ReadStoriesFromCache = gql`
    query ReadStories {
      stories {
        id
      }
    }
  `;

  function StoryEditor() {
    function saveStory(newStory) {
      mutate({
        variables: {...},
        update: (cache, {data}) => {
          const { posts } = cache.readQuery({
            query: ReadStoriesFromCache
          });
          cache.writeQuery({
            query: ReadStoriesFromCache,
            data: { posts: stories.concat(data.newStora) }
          });
      })
    }

    return ...;
  }
  ```

---
### Aktualisieren des Caches mit Subscriptions
<!-- .slide: class="left" -->
* Bei den bisher gesehen Aktualisierungen, hat der Client die Aktualisierung
  ausgel√∂st.
* Dadurch werden √Ñnderungen an Daten, die nicht vom Server vorgenommen werden, aber nicht
  ber√ºcksichtigt
* Beispiel: Anderer Benutzer erzeugt einen Kommentar
* Man kann das Query-Ergebnis (insb. f√ºr Listen) mit einer Subscription aktualisieren
* Beispiel: onNewComment Subscription
---
### Aktualisieren des Caches mit Subscriptions
<!-- .slide: class="left" -->
* `useQuery` stellt dazu die Funktion `subscribeToMore` zur Verf√ºgung
* Dieser Funktion wird √ºbergeben:
  * Als Typ-Parameter der Name des Typs, der das Ergebnis der Subscription beschreibt
  * Als Parameter ein Objekt:
    * mit `document` (Ergebnis des `gql`-Aufrufs mit der Subscription bzw. des generierten Codes)
    * evtl. `variables` f√ºr die Mutation
    * `updateQuery`-Funktion
* Immer wenn die Subscription neue Daten liefert, wird die Callback-Funktion `updateQuery`
  mit den alten und neuen Daten aufgerufen
* In `updateQuery` k√∂nnen die neuen Daten dem Cache hinzugef√ºgt werden
* <!-- .element: class="demo" --> Cache Verhalten in Apollo Dev Tools

---
### Aktualisieren von Listen mit Subscriptions
<!-- .slide: class="left" -->

* ```javascript
  function StoryComments({ storyId }) {

    // initial Kommentare f√ºr eine Story lesen
    const { data, loading, error, subscribeToMore } = useStoryCommentsQuery({
      variables: { storyId },
    });

    React.useEffect(() => {

      // Aktualisieren der Liste im Cache mit Subscription
      subscribeToMore<OnNewCommentSubscription>({
        document: OnNewCommentDocument,
        variables: { storyId },
        updateQuery: (prev, { subscriptionData }) => {
          // Wenn die Subscription keine Daten geliefert hat (z.B. Fehler)
          // den alten Cache-Inhalt unver√§ndert zur√ºckliefern
          if (!subscriptionData.data) return prev;

          // Bestehenden Cache-Inhalt ('prev') kopieren und in das
          // 'comments'-Feld den neuen Kommentar einf√ºgen

          // Achtung! Wie das einf√ºgen genau funktioniert, h√§ngt nat√ºrlich
          //  immer von deiner jeweiligen Daten-Struktur ab
          const newComment = subscriptionData.data.onNewComment.newComment;
          const newData = Object.assign({}, prev, {
            comments: [newComment, ...prev.comments],
          });

          // Neuen Wert zur√ºckliefern; dieser ersetzt dann
          // den gecachten Wert des Queries, f√ºr den diese
          // updateQuery-Funktion ausgef√ºhrt wurde
          return newData;
        },
      });
    }, [subscribeToMore, storyId]);

    return ...;
  }
  ```
---

### √úbung: subscribeToMore
* Die Liste der Kommentare (`StoryComments`) soll automatisch aktualisiert werden,
  wenn auf dem Server ein neuer Kommentar erzeugt wird
* Implementiere dazu die `subscribeToMore`-Funktion
* TODOs und Hilfestellung dazu findest Du in der Datei `StoryComments.tsx`
* L√∂sung in `steps-frontend/30_useQuery_subscribeToMore`
  </textarea
          >
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit GraphQL!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            <a
              href="https://www.xing.com/profile/Nils_Hartmann2/cv"
              target="_blank"
              >Xing</a
            >
          </p>

          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>
    <script src="revealjs/reveal.js/dist/reveal.js"></script>
    <script src="revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="revealjs/config.js"></script>
  </body>
</html>
