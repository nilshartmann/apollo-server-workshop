<html lang="de">
  <!DOCTYPE html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>GraphQL APIs bauen</title>

    <link rel="stylesheet" href="revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="revealjs/styles.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-state="title">
          <h4 style="margin-bottom: 3rem; font-size: 3rem">
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>
          <h2 class="title" style="font-size: 7rem">
            <b>GraphQL APIs bauen</b>
          </h2>
          <h3 class="title" style="font-size: 5rem">
            <b>Ein praktischer Einstieg mit Apollo Server</b>
          </h3>
          <h3 class="title" style="font-size: 3rem; margin-bottom: 3rem">
            <b>JavaScript Days, 20. Oktober 2022</b>
          </h3>

          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Slides (online)</span></h3>
            <p>
              <a class="Link" href="https://graphql.schule/jsdays2022"
                >https://graphql.schule/jsdays2022</a
              >
            </p>
          </div>
          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Workspace Installation</span></h3>
            <p>
              <a
                class="Link"
                href="https://github.com/nilshartmann/spring-graphql-training/blob/main/INSTALL.md"
                >https://graphql.schule/jsdays-2022-install</a
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!--        <section>-->
        <!--          <h2>Und ihr?</h2>-->
        <!--          <ul>-->
        <!--            <li>Stellt euch doch bitte kurz vor...</li>-->
        <!--            <li>-->
        <!--              Eure Vorkenntnisse in <b>GraphQL</b>, <b>Java</b>, <b>Spring?</b>,-->
        <!--              <b>React/TypeScript</b>-->
        <!--            </li>-->
        <!--            <li>-->
        <!--              W√ºnsche f√ºr diese Schulung? Besondere Themen oder Interessen?-->
        <!--            </li>-->
        <!--          </ul>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>

## Kurze Vorstellung

* Mentimeter Umfrage:
  * Was ist Eure bisherige GraphQL Erfahrung?
  * Was verwendet ihr normalerweise an Technologie?
  * Link im Chat

---

## Agenda

* Teil 1: GraphQL
  * Was ist GraphQL?
  * [Die Abfragesprache](#/graphql-sprache)

* Teil 2: [GraphQL APIs bereitstellen](#/graphql-apis-bereitstellen)
  * [Das Schema Definieren](#/schema)
  * [Implementieren der API](#/api-implementieren)
    * [Resolver-Funktionen](#/resolver-funktionen)
    * [Fehlerbehandlung](#/fehlerbehandlung)
    * [Der GraphQL Context](#/graphql-context)
    * [Externe Services integrieren](#/externe-systeme-integrieren)
    * [Testen](#/testen)
    * [TypeScript](#/typescript)

---

## Zeitplan

* 09:00 bis 12:30 Teil 1
* 12:30 bis 13:30 Mittag üçï üçù
* 13:30 bis 17:00 Teil 2
* Zwischendurch Pausen ‚òïÔ∏è üç∞

---


## Grunds√§tzliches

* **Jederzeit:** Fragen und Diskussionen! Bringt Euch gerne ein!
* Motto: Es gibt keine dummen Fragen!
* Ich zeige viel direkt im Editor, aber ihr k√∂nnt die Slides als Referenz benutzen

---

# GraphQL


_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---

# GraphQL


_"GraphQL is a **query language for APIs** and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a **runtime for fulfilling** those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with **your existing data**"_ ([https://graphql.org](https://graphql.org))

---

## Spezifikation

* https://spec.graphql.org/
* Umfasst:
  * Query Sprache und -Ausf√ºhrung
  * Schema Definition Language
* Kein fertiges Produkt, keine fertige Bibliothek
   * Es gibt Bibliotheken, die dir helfen, GraphQL APIs zu implementieren und bereitzustellen
   * Die abgefragten Daten m√ºssen wir selbst ermitteln
   * GraphQL macht keine Aussage dar√ºber, wo diese Daten herkommen (Datenbank, Micro-Service, Berechnung ...)

---

## Die Beispiel-Anwendung

<img style="border: 1px solid grey" src="images/publy-screenshot.png" />

[http://localhost:3000](http://localhost:3000)

---

## Beispiel: GraphiQL

<img style="border: 1px solid grey" src="images/screenshot-graphiql.png" />

[http://localhost:8080](http://localhost:8080)

---


## Beispiel: GraphQL Tooling

* <!-- .element: class="demo" --> IntelliJ IDEA
  * <!-- .element: class="demo" --> graphql-Extension (hello.graphql)
  * <!-- .element: class="demo" --> GraphQL.md im publy-Verzeichnis
  * <!-- .element: class="demo" --> language=GraphQL in einer leeren Java-Datei

* <!-- .element: class="demo" --> TypeScript (optional)
  * <!-- .element: class="demo" --> publy-frontend, npm run codegen:watch
  * <!-- .element: class="demo" --> StoryPage.query.graphql zeigen und story-Feld entfernen
---

<!-- .slide: id="graphql-sprache" -->
# Die GraphQL Abfrage-Sprache
---

### Sprache, um **Felder** aus einem **Objekt-Graphen** abzufragen

```graphql
  query {
    story {
      id title writtenBy {
        id user { name }
      }
    }
  }

---

### Felder k√∂nnen **Argumente** haben

<pre><code class="graphql">
  query {
    story(storyId: 5) {
      id title writtenBy {
        id user { name }
      }
    }
  }
</code></pre>

---

### Die **Antwort** sieht immer so aus, wie die Abfrage

<img src="images/query-antwort.png" />

---

### Operation-Type

Ausgef√ºhrt werden **Operationen**.
Der **Operation-Type** beschreibt, was in der Anfrage getan werden soll

* **query**: Daten lesen (Default-Operation, Schl√ºsselwort "query" kann weggelassen werden)
* **mutation**: Daten ver√§ndern
* **subscription**: Daten vom Server bekommen, sobald sie erzeugt wurden (√§hnlich wie Events)

---


### Operation-Type

Der Operation-Type bestimmt auch den Einstiegspunkt in den Objekt-Graphen

<img src="images/einstiegspunkte.png" />

---

### Namen von Operationen

* Operationen k√∂nnen **Namen** haben.
* Das ist vor allem f√ºr Debugging und Code-Generatoren relevant

* ```graphql
  query NewestStory {
      story {
        id
        title
      }
  }
  ```

---

### Fragmente

* Mit einem **Fragment** beschreibst Du eine wiederverwendbare Menge von Feldern
* ```graphql
  fragment BaseMember on Member {
      id joined
      user { is username }
  }

  query {
      story {
        writtenBy { ...BaseMember }

        comments {
          givenBy { ...BaseMember }
        }
      }
  }
  ```


---

### Variablen

* Queries k√∂nnen **Variablen** haben.
* Variablen m√ºssen im Query deklariert werden
* Werte f√ºr Variablen werden in einem eigenen JSON-Objekt an den Server geschickt

* ```graphql
  query ($storyId: ID!) {
    story(id: $storyId) {
      id
      title body
    }
  }
  ```

---

## √úbung: Einen Query ausf√ºhren

_Mach' dich mit der GraphQL-Abfragesprache vertraut_

* √ñffne GraphiQL auf meinem Computer (URL gebe ich euch)
* Versuche einen Query auszuf√ºhren, der die ersten vier Stories zur√ºckliefert und folgende Felder abfragt:
  * Id, Titel, Excerpt, Ver√∂ffentlichungsdatum, Wer hat die Story geschrieben und die jeweils ersten zehn Kommentare
  * Kannst Du den Query so erweitern, dass er die ersten zehn _neusten_ Stories zur√ºckliefert?
* Bau eine Fragment (`Author`), das aus dem `Member` dessen Id, sowie `fullname` und `id` des Users enth√§lt
  * Verwende das Fragment, um in den Stories und den Kommentaren jeweils die Member-Informationen abzufragen
  * In den Stories zus√§tzlich noch `skills` des Members abfragen
* Du kannst Code-Completion und den `Docs`-Explorer (rechts oben) verwenden, um die API zu untersuchen
* M√∂gliche L√∂sungen findest Du auf den folgenden Slides.

---
## L√∂sung: vier Stories mit Kommentaren

```graphql
query($page: Int!, $pageSize: Int!) {
  stories(page: $page,pageSize: $pageSize) {
    stories {

      id
      title
      excerpt
      createdAt
      writtenBy {
        user {
          fullname
        }
      }
      comments {
          id
          content
        }
      }
    }
  }
}
```
```json
{
  "pageSize": 4,
  "page": 0
}
```
---
## L√∂sung mit Sortierkriterium
```graphql
query($page: Int!, $pageSize: Int!, $sortBy: StorySortCriteria) {
  stories(page: $page,pageSize: $pageSize, sortBy: $sortBy) {
    stories {

      id
      title
      excerpt
      createdAt
      writtenBy {
        user {
          fullname
        }
      }
      comments {
          id
          content
        }
      }
    }
  }
}
```
```json
{
  "page": 0,
  "pageSize": 4,
  "sortBy": {
    "field": "date",
    "direction": "desc"
  }
}
```
---
## L√∂sung mit Fragment
```graphql
fragment Author on Member {
  id user { fullname id }
}

query($pageSize: Int!, $sortBy: StorySortCriteria) {
  stories(pageSize: $pageSize, sortBy: $sortBy) {
    stories {
      id
      title
      excerpt
      createdAt
      writtenBy {
        ...Author
        skills
      }
      comments {
          id
          content

          writtenBy { ...Author }
        }
      }
    }
  }
}
```
```json
{
  "sortBy": {
    "direction": "desc",
    "field": "date"
  },
  "pageSize": 4
}
```

---

### GraphQL Requests

* <!-- .element: class="demo" --> HTTP Request an die GraphQL API
  * <!-- .element: class="demo" --> request.http im publy-Ordner
  * <!-- .element: class="demo" --> Fehler zeigen
---

## GraphQL Requests

* √úblicherweise nur HTTP POST-Request
  * andere HTTP Verben spielen keine Rolle
  * HTTP Status-Code meist 200 OK, auch im Fehlerfall!
  * Gro√üer Unterscheid zu REST APIs
* Antwort-JSON-Objekt besteht aus maximal drei Feldern:
  * `data`: Die gelesenen Daten (Struktur darunter entspricht der Abfrage)
  * `errors`: Liste mit (technischen) Fehlern, u.a. Fehlermeldung
  * `extensions`: Freibelegbares Objekt f√ºr propriet√§re Erweiterungen (z.B. Debug-Informationen)

---

### Union-Typen

Ein **Union-Type** kann mehr als einen Typ zur√ºckliefern:

```graphql
  mutation  addComment
      (input: { storyId: "1", content: "..." }) {

      ...on AddCommentSuccessPayload {
        newComment { id }
      }

      ...on AddCommentFailurePayload {
        errorMessage
      }
  }
```

---
### Interfaces

* Ein Interface erzwingt gemeinsame Felder an den Objekten, die das Interface implementieren (√§hnlich
    wie in Java mit Methoden)

* Beispiel: `id` und `createdAt` sind am `Node`-Interface definiert

* ```graphql
  query {
      node(id: "...") {

        id
        createdAt

        ...on Story { title body }
        ...on Comment { content }
      }
  }
  ```

---
### Mutations und Subscriptions

* Mutations und Subscriptions sind syntaktisch wie Queries
* Bei einer Mutation werden Daten auf dem Server ver√§ndert
* Bei einer Subscription werden Daten vom Server auf den Client geschickt (Events)
---

## √úbung: Mutations
* F√ºhre eine Mutation aus, die einen neuen Kommentar erzeugt
* Du musst dazu in der Apollo Sandbox im `Headers`-Tab den Header `X-Authorization` setzen, z.B. auf `U3`
* <img src="images/auth-header.png" height="400px" />
* Frage aus der Antwort im Erfolgsfall die Id des neuen Kommentars, sowie dessen Story und deren Kommentare ab (in der Liste sollte dein neuer Kommentar nun enthalten sein)
* Im Fehlerfall frage das `errorMsg`-Feld ab
* M√∂gliche L√∂sung auf der n√§chsten Slide
---
## L√∂sung: Mutation
```graphql
mutation($input: AddCommentInput!) {
  addComment(input: $input) {
    ...on AddCommentSuccessPayload {
      newComment {
        id
         story {
           title
           comments {
             id
             content
           }
         }
      }
    }
    ...on AddCommentFailedPayload {
      errorMsg
    }
  }
}
```
```json
{
  "input": {
    "content": "Neuer Kommentar",
    "storyId": "7"
  }
}
```
---
### Teil II
<!-- .slide: id="graphql-apis-bereitstellen" -->
# GraphQL APIs bereitstellen

---
<!-- .slide: id="schema" -->
### Das GraphQL Schema

* GraphQL APIs m√ºssen in einem Schema beschrieben werden.
* In dem Schema werden Objekte (Typen) mit Feldern beschrieben.
* Das Schema selbst ist zur Laufzeit mit einem _Introspection Query_ abfragbar
  * üßë‚Äçüíª Beispiel im Playground
* Mit der [Schema Definition Language](https://graphql.org/learn/schema/)

---

### Die SDL

* <!-- .element: class="demo" --> Demo: Schema-Definition 
  * <!-- .element: class="demo" --> ping-Feld mit Message Object
  * <!-- .element: class="demo" --> Argument!
  * <!-- .element: class="demo" --> R√ºckgabewert-String
  * <!-- .element: class="demo" --> Doku

---

### Die SDL

Beschreibung eines *Objekt Types*

<pre><code class="graphql">
  type Story {
    id: ID!

    title: String!
    body: String!
  }
</code></pre>

* Beschrieben werden **Felder** mit **Return Types**
* Ein Ausrufezeichen zeigt an, dass das Feld nicht _nullable_ ist

---

### Dokumentation und Kommentare

* Dokumentation mit drei doppelten Anf√ºhrungszeichen
  * Markdown zur Formatierung erlaubt
* Kommentare mit Hash-Zeichen
  * Dokumentation ist Bestandteil der API, Kommentare nicht

* ```graphql
  """
  A `Story` is the main object in our service.
  """
  type Story {
    """Identifies this object"""
    id: ID!

    # todo: implement new tags-field (PROJ-666)
  }
  ```

---

## Skalare Typen

* Skalare Typen entsprechen primitiven Typen in JavaScript
  * Sind die Enden im Objekt-Graphen
* Standard-Typen: ID, String, Boolean, Int, Float
  * ID wird als String gelesen und geschrieben, soll aber nicht interpretiert werden


* ```graphql
  type Member {
    id: ID!

    username: String!

    # no exclamation mark: can be null
    likes: Int

    amount: Float!

    activeMember: Boolean
  }
  ```
  

* Man kann eigene skalare Typen bauen
---

### Aufz√§hlungstypen (enum)

* Wie in TypeScript

* <!-- .element: style="min-width: 500px" -->
  ```graphql
  enum ReactionType {
    like,
    laugh,
    thumbUp
  }
  ```

---

### Referenzen

* Referenzen auf andere Objekt-Typen

* <!-- .element: style="min-width: 900px" -->
  ```graphql
  type Member {
    # ...
  }

  type Comment {
    # ...
  }

  type Story {
    """Reference to the Member that has written this Story"""
    writtenBy: Member!

    comments: [Comment!]!

  }
  ```

---

### Argumente

* Felder k√∂nnen Argumente haben
  * Solche Felder werden auch _Methoden_ genannt
* Die Felder mit ihren Namen und Typen m√ºssen in der API definiert werden
  * Namen sind entscheidend (wie in Objekten an Funktionsparametern in JS), nicht Reihenfolge (wie in JavaScript)
* Argumente k√∂nnen Default-Werte haben
* Achtung! Argumente d√ºrfen keine Objekt-Typen sein!  


* ```graphql
  type Story {

    # Mandatory argument maxLength, defaults to 20
    #  if not specified by the client
    excerpt(maxLength: Int! = 20): String!

  }
  ```

---

### Root-Typen

* Root-Typen bilden den Einstiegspunkt f√ºr Queries in den Objekt-Graphen
* Root-Typen sind **Query**, **Mutation** und **Subscription**
  * **Query** ist Pflicht, die beiden anderen Typen optional
* Syntax und Verhalten genauso wie bei Objekt-Typen
* Felder an den Root-Typen werden auch **Root-Felder** genannt


* ```graphql
  type Query {
    """Returns a List of all stories"""
    stories: [Story!]!

    """Returns a story by its ID or null"""
    story(id: ID!): Story
  }

  type Mutation {
    addComment(storyId: ID!, memberId: ID!, content: String!): Comment!
  }
  ```
---

### Input-Typen

* Objekt-Typen k√∂nnen nicht als Argument an ein Feld √ºbergeben
* Als Argumente an Feldern k√∂nnen nur skalare Typen, Enums und Input-Typen √ºbergeben werden.
* Ein Input-Type wird mit `input` definiert, sieht ansonsten aus wie ein Objekt-Type
  * Ein Input-Type darf keine Objekt-Typen referenzieren

* ```graphql
  input AddCommentInput {
    storyId: ID!
    memberId: ID!
    content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
  ```

---

### Union Types

* Union Types bilden eine Menge von anderen Typen
* Ein Feld kann ein Typen aus dieser Menge zur√ºckliefern ("A _oder_ B")


* ```graphql
  type AddCommentSuccess { newComment: Comment! }
  type AddCommentFailed { errorMessage: String! }

  union AddCommentResult = AddCommentSuccess | AddCommentFailed

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentResult!
  }
  ```


---

### Interfaces

* Mit einem Interface wird erzwungen, dass Objekte √ºber gleiche Felder verf√ºgen
  * Vergleichbar mit Interfaces in TypeScript


* ```graphql
  interface Node {
    id: ID!
  }

  type Story implements Node {
    id: ID!  # Field defined in Node-Interface

    title: String! # additional Story fields
  }

  type Comment implements Node {
    id: ID! 

    content: String!
  }

  type User {
    id: ID!
    email: String
  }

  type Query {
    # Returns either Story or Comment, but not User

    node(id: ID!): Node 
  }
  ```

---

### Schema-Evolution

* In GraphQL gibt es nur _eine Version_ der API (kein `/api/v1`, `/api/v2`)
* Das Schema kann jederzeit erweitert werden
  * Clients fragen explizit Felder ab, d.h. durch neue Felder werden sie nicht beeintr√§chtigt
* Man kann Felder mit `deprecated` markieren, um anzuzeigen, dass sie nicht genutzt werden sollen  

* ```graphql
  type Query {
    # Ausgangspunkt 
    getStoryById(id: ID!): Story
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story

    # Neues Feld, beeintr√§chtigt bestehenden Client nicht
    stories: [Story!]!
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story @deprecated("Use story instead")
    story(id: ID!): Story

    stories: [Story!]!
  }
  ```
---
### _Eine_ API f√ºr ganze Anwendung

* √úblicherweise hat eine Anwendung *eine* GraphQL API
  * In REST gibt es mehrere Endpunkte, die auf unterschiedliche Server verteilt sein k√∂nnen
  * GraphQL soll zentrale API sein
  * Untereinander kommunizieren die Services per REST o.√§.
---

### √úbung: Schema beschreiben

---

### Vorbereitung: Das Repository

* `workspace`: Hier arbeiten wir, bitte in der IDE √∂ffnen
  * Ggf. `pnpm install` ausf√ºhren
  * `pnpm dev` zum Starten ausf√ºhren
  * Das Projekt ist in TypeScript geschrieben, sollte aber auch mit JavaScript-Syntax funktionieren.
* `steps`: L√∂sungen f√ºr die einzelnen √úbungen
* `app`: Fertige Anwendung auch mit Frontend

---
### √úbung: Schema beschreiben
* <!-- .element: class="very-small" -->
* Vervollst√§ndige die Datei `src/graphql/schema.graphql` und beschreibe darin eine API, die folgende Objekt-Typen enth√§lt:
  * **Member** mit `id` und `profileImage`
  * **Story** mit `id`, `title`, `body`, `excerpt` und einer Referenz (`writtenBy`) auf den Member
    * Das `excerpt`-Feld soll ein Argument haben: `maxLength` vom Typ int (Pflicht)
  * Alle Felder in den beiden Typen sind Pflicht (non-nullable), das `id`-Feld ist vom Typ `ID` alle anderen Strings
* Lege den Query-Typen mit folgenden Feldern an:
  * `allStories`: Liefert eine Liste der `Story`-Objekte zur√ºck. Nicht nullable.
  * `story`: Liefert eine einzelne Story zur√ºck. Das Feld soll ein Argument haben: `storyId`. Das Feld kann `null` zur√ºckgeben
* F√ºge f√ºr das `story`-Feld Dokumentation hinzu
* In der "Apollo Sandbox" (http://localhost:4000/graphql) kannst Du deine API sehen und Queries formulieren, das Ausf√ºhren funktioniert nat√ºrlich noch nicht
* Eine m√∂gliche L√∂sung findest Du in `steps/01-schema`

---


<!-- .slide: id="api-implementieren" -->
## Implementieren der GraphQL API

---

### Apollo Graphql

* Urspr√ºnglich Open-Source GraphQL Server und Client
* Apollo bietet mittlerweile (kommerzielle) Services f√ºr alles rund um GraphQL an
* Vermarkten auch propriet√§re Ideen, wie Federation, "GraphOS" und "Supergraph"

---
### Apollo Server

 * https://www.apollographql.com/docs/apollo-server/
  * "All-inclusive"-L√∂sung
  * "Standalone" Server oder als Middleware f√ºr Express
  * Integration in andere Webserver (wie Hapi) √§ndern sich von Version zu Version
  * Basiert auf der "reinen" JavaScript Referenz-Implementierung [graphql-js](https://github.com/graphql/graphql-js)
* [Apollo Sandbox](https://www.apollographql.com/docs/studio/explorer/sandbox/) zur Ausf√ºhrung von Queries
  * Achtung! Tracking!
  * Prominente Open-Source-Alternative: [GraphiQL](https://github.com/graphql/graphiql)
* Caching von Ergebnissen
* Automatic persisted queries: Queries per ID ausf√ºhren
* "Federation": Zusammenf√ºhren verschiedener GraphQL APIs

---

### Verarbeitung eines GraphQL Queries (allgemein)


1. <!-- .element: class="xx-list" --> Query kommt an (HTTP Endpunkt)
2. Query wird geparst und validiert
3. Ung√ºltige Queries werden abgewiesen (`errors`-Feld in der Antwort)
4. F√ºr jedes Feld wird eine *Resolver-Funktion* aufgerufen, die verantwortlich daf√ºr ist, die Daten f√ºr das jeweilige Feld zu liefern
5. Die Ergebnisse der Resolver werden validiert (insb. hinsichtlich der Typen)
6. Das Ergebnis wird als `data`-Feld bereitsgestellt
7. Das Ergebnis wird an den Client zur√ºckgeschickt

<!-- end of the list -->

* <!-- .element: class="note" --> Unsere Aufgabe ist es, die Resolver-Funktionen zu implementieren
---

### Apollo Server

* **Konfiguration und Start** √ºber `ApolloServer`-Objekt
* Der Server erwartet ein *executable Schema* (Schema-Beschreibung und Resolver-Funktionen)
* Je nach Laufzeitumgebung kann der Server standalone laufen (Express integriert) oder explizit in eine
            vorhandene Express Instanz integriert werden
* ```javascript
  import { ApolloServer } from "@apollo/server";

  const typeDefs = /* sp√§ter */
  const resolvers = /* sp√§ter */

  const schema = makeExecutableSchema({ typeDefs, resolvers });
  const app = express();
  const httpServer = http.createServer(app);
  const server = new ApolloServer({
      schema,
  });

  await server.start();

  app.use("/graphql",
      expressMiddleware(server)
  );

  httpServer.listen({ port: 4000 });
  ```

---

### Bereitstellen des Schemas

* Das Schema wird grunds√§tzlich mit der SDL beschrieben
* Entweder in externer Datei oder direkt im Source-Code
* Beispiel 1: Direkt im Source Code
  * ```javascript
  // language=GraphQL
    const typeDefs = `
      type Query { ping: String! }
    `
  ```
* Beispiel 2: Aus Datei lesen
  * ```javascript
  const typeDefs = readFileSync(
    path.resolve(__dirname, "graphql/schema.graphql"),
    "utf8"
  );
  ```


---

### Resolver-Funktionen
<!-- .slide: id="resolver-funktionen" -->


* **Ein Resolver liefert den Wert f√ºr ein angefragtes Feld in einer Operation**
* Zwingend erforderlich f√ºr jedes Root-Field (in den Query, Mutation und Subscription-Types)
  * falls keine Resolver-Funktion hinterlegt ist f√ºr ein Feld, greift ein Default Resolver
  * der Default-Resolber ermittel die Werte an Hand von Feldern oder Funktionen an Objekten
* Ein Resolver kann einen Wert zur√ºckliefern oder ein Promise f√ºr den Wert

---

### Beispiel: Resolver-Funktionen

* <!-- .element: class="demo" --> Demo: Resolver- mit Person-Feld
* <!-- .element: class="demo" --> Schema-Mapping! (fullname)
* <!-- .element: class="demo" --> Argumente!

---

### Resolver-Funktionen
* Resolver werden in der *Resolver Map* gehalten. Das ist ein JavaScript-Objekt:
* Key darin ist der Name eins GraphQL Objekts (z.B. `Query` oder `Story`)
* Als Wert dazu ist ein weiteres Objekt mit den Resolver-Funktionen hinterlegt:
  * In diesem Objekt ist der Key der Name eines Feldes an dem GraphQL Typen
  * Der Wert ist eine Funktion, die den Wert f√ºr das Feld ermittelt
* Beispiel f√ºr einen *Root*-Resolver:
  * ```javascript
    const resolvers = {
      Query: {
        ping: () => "Hello World"
      }
    }
    ```
---
### Resolver-Funktionen
* Signatur 1: `feldname(source, args, context, info): Wert`
* Signatur 2: `feldname(source, args, context, info): Promise<Wert>`
* Resolver-Funktionen k√∂nnen drei Argumente entgegennehmen:
  1. Das Source- oder Parent-Objekt
  2. Die f√ºr das Feld √ºbergebenen Argumente
  3. Das GraphQL Context-Objekt
  4. Meta-Informationen √ºber den Query
---

### Resolver-Funktionen: Argumente

* Die an ein Feld √ºbergebenen Argumente werden in einem Objekt an das _zweite_ Argument des Resolvers √ºbergeben
* Es werden nur Werte √ºbergeben, die gem√§√ü Schema g√ºltig sind
  * Bei nicht g√ºltigen Werten wird der Query abgelehnt
* ```graphql
  type Story { id title body }

  type Query {
    story(storyId: ID): Story
  }
  ```
* ```javascript
  const resolvers = {
    Query: {
      story(_, { storyId }) {
        return db.getStoryById(storyId);
      },
    }
  }
  ```
---
### Resolver-Funktionen: Das Parent-Objekt
* Alle nicht-Root-Resolver bekommen ihr jeweiliges Parent-Objekt als ersten Parameter √ºbergeben
* Das Parent-Objekt ist das Objekt, das der vorherige Resolver zur√ºckgeliefert hat
* ```graphql
  type Story {
    id title body
    excerpt(maxLength: Int! = 10)  # excerpt nicht am JavaScript Story Object!
  }

  type Query {
    story(storyId: ID!): Story
  }
  ```
* ```javascript
  const resolvers = {
    Query: { /* wie gesehen... */ },
    Story: {
      excerpt(story, { maxLength } ) {
        return story.body.substring(0,maxLength);
      }
    }
  }
  ```
---
### Resolver-Funktionen: Das Context-Objekt
* Mit dem Context-Objekt k√∂nnen Informationen pro Query erzeugt und an alle Resolver √ºbergeben werden
  * Zum Beispiel Header aus dem HTTP Request (Authorization, ...)
* Mehr dazu sp√§ter
---
### Resolver f√ºr Mutations

* Resolver f√ºr den Mutation-Typen werden ebenfalls in die ResolverMap aufgenommen.
* Signatur der Funktionen ebenfalls identisch
* Einziger (semantischer) Unterschied: in den Mutation Resolvern d√ºrfen Daten ver√§ndert werden
* ```javascript
  const resolvers = {
    Query: { /* ... */ },

    Mutation: {
      addComment(_, { input }) {
        return publyDomainService.addCommentToPost(input.storyId, input.content);
      }
    }
  }
  ```
---
### Resolver registrieren

* Die Resolver werden an die `ApolloServer`-Instanz √ºbergeben
  * Entweder als `executableSchema`
    * ```javascript
      const resolvers = { Query: { /* ... */ } };
      const schema = makeExecutableSchema({ typeDefs, resolvers });
      const server = new ApolloServer({
        schema,
        // ...
      })
      ```
  * Oder als eigene Konfigurationsoption
    * ```javascript
      const resolvers = { Query: { /* ... */ } };
      const server = new ApolloServer({
        typeDefs,
        resolvers
        // ...
      })
      ```
---
### Resolver modularisieren
* Nat√ºrlich k√∂nnt ihr die Resolver auch auf unterschiedliche Module aufteilen
* Beispiel:
  * ```javascript
    import { queryResolvers } from "./query.resolver"; // { story() { ... } }
    import { storyResolvers } from "./query.resolver"; // { excerpt() { ... } }

    const resolvers = {
      Query: queryResolvers,
      Story: storyResovers
    }

    const server = new ApolloServer({
        typeDefs,
        resolvers
        // ...
    })
    ```
---

### √úbung: Resolver implementieren

* **Implementiere die Resolver f√ºr `Query.allStories`, `Query.story` und `Story.excerpt`**
* Du musst die √Ñnderungen in `src/graphql/resolver.ts` machen (Du brauchst keine TypeScript-Typen hinschreiben)
* Zum Ermitteln der Story bzw. Stories kannst Du den `publyDomainService` verwenden, der aus `src/domain/PublyDomainService.ts` exportiert wird
* Das `Story.excerpt` Feld soll die ersten `maxLength` Zeichen aus dem `body`-Feld Story zur√ºckliefern. (Erinnerung: `maxLength` ist ein Argument am `excerpt`-GraphQL Feld)
* Falls Du mit der √úbung 1 (Schema beschreiben) nicht fertig geworden bist, kopiere dir `steps/01-schema/src/graphql/schema.graphl`
          in dein Workspace-Verzeichnis
* Wenn Du die drei Resolver korrekt implementiert hast, m√ºssen die Queries auf der folgenden Slide funktionieren
* Eine L√∂sung findest Du im Verzeichnis `steps/02-resolver`

---
### √úbung: Resolver #2
* Der folgende Query sollte funktionieren, wenn Du den Resolver f√ºr `allStories` korrekt implementiert hast:
  * ```graphql
    query {
      allStories {
        id title body
        writtenBy { id profileImage }
      }
    }
    ```

* Der Query sollte funktionieren, wenn Du den `Query.story`-Resolver implementiert hast:
  * ```graphql
    query {
      story(storyId: "1") {
        id title body
        writtenBy { id profileImage }
      }
    }
    ```
* Der Query sollte funktionieren, wenn Du den `Story.excerpt`-Resolver implementiert hast (die Werte f√ºr
            das `excerpt`-Feld sollten dann nat√ºrlich max. zehn Zeichen lang sein üòâ
  * ```graphql
    query {
      allStories {
        id
        title
        excerpt(maxLength: 10)
      }
    }
    ```
---
### Fehlerbehandlung
<!-- .slide: id="fehlerbehandlung" -->

* Was ist an folgender API problematisch?
* ```graphql
  input AddStoryInput {
    title: String!
    body: String!
  }

  type Mutation {
    addStory(input: AddStoryInput!): Story!
  }
  ```
* Es wird *immer* ein Story-Objekt zur√ºckgegeben!
* Was passiert, wenn die Story nicht angelegt werden konnte?

---

### Resolver: Union-Types

* Wenn ein Resolver einen Union-Typen zur√ºckliefert, muss Apollo wissen, welchem GraphQL-Typen dein Resolver-Ergebnis entspricht
* Beispiel Mutation:
  * ```graphql
    type AddStorySuccess { storyAdded: Story! }

    type AddStoryFailed { error: String! }

    union AddStoryResponse = AddStorySuccess | AddStoryFailed

    type Mutation {
      addStory(input: AddStoryInput!): AddStoryResponse!
    }  
    ```
* Apollo muss wissen, ob das zur√ºckgelieferte (JavaScript-)Objekt vom Resolver f√ºr `Mutation.addStory` dem GraphQL Typen `AddStorySuccess` oder `AddStoryFailed` entspricht
* Dazu musst Du einen Resolver mit dem Namen `__resolveType` bauen und zwar f√ºr den Union-Typen (hier also `AddStoryResponse.__resolveType`)
* Diese Funktion wird dann mit dem Ergebnis eines Resolvers aufgerufen, der den Union-Typen zur√ºckgegeben hat (`Mutation.addStory`)
* Die Resolver-Funktion muss dann pr√ºfen, um welche konkrete Auspr√§gung des Union-Types es sich handelt und den Namen des GraphQL-Typen als String zur√ºckliefern (`"AddStorySuccess"` oder `"AddStoryFailed"`)

---
### Resolver: Union-Types
<!-- .slide: class="left" -->
* Beispiel:
* ```javascript
  const resolvers = {
    // ...
    AddStoryResponse: {
      __resolveType(addStoryResult) {

        // Annahme: das addStoryResult JS-Objekt enth√§lt
        // ein Feld "storyAdded", wenn es ein "erfolgreiches"
        // Ergebnis ist. 

        if ("storyAdded" in addStoryResult) {
          return "AddStorySuccess";
        }
        return "AddStoryFailed";
      },
    },
  }
  ```
---

---
## √úbung: Mutations und Union Types
* **Implementiere die Resolver-Funktion f√ºr die `addComment`-Mutation**
*  Bitte das erweiterte Schema aus `material/comment-schema.graphql` kopieren und ans Ende deiner `src/graphql/schema.graphql`-Datei kopieren
*  Implementiere den fehlenden Resolver: `Mutation.addComment` in `resolver.ts`
  * Zum Speichern des Kommentars kannst Du `publyDomainService.addComment` aufrufen. √úbergib f√ºr den `userId`-Parameter im ersten Schritt einfach `U3`
  * Wenn ein Fehler fliegt, fange diesen mit `catch` auf und gib den Fehlertypen (`AddCommentFailedPayload`) mit einer Fehlermeldung zur√ºck. 
  * (Du kannst zum Testen einen Fehler provozieren, in dem Du einen Kommentar anlegst, der weniger als f√ºnf Zeichen lang ist)
  * Im Erfolgsfall gib den neuen Kommentar als `AddCommentSuccessPayload`-Typen zur√ºck
* Implementiere au√üerdem den `__resolveType`-Resolver f√ºr den Union-Typen `AddCommentPayload`
*  Wenn alles korrekt implementiert ist, sollten die beiden Mutations auf der folgenden Seite funktionieren.
---

### √úbung: Union Types

* Funktionierende Mutation (`newComment` sollte gef√ºllt sein):
* ```graphql
  mutation {
    addComment(input: {
      content: "Toller Artikel!",
      storyId: "2"
    }) {
      ...on AddCommentFailedPayload { errorMsg }

      ...on AddCommentSuccessPayload {
        newComment {
          id 
          story { id }   
          writtenBy { id }
        }
      }
    }
  }
  ```
* Mutation, die das `errorMsg` mit einer Fehlermeldung f√ºllen soll:
* ```graphql
  mutation {
    addComment(input: {
      content: "Toll",
      storyId: "2"
    }) {
      ...on AddCommentFailedPayload { errorMsg }

      ...on AddCommentSuccessPayload {
        newComment {
          id 
          story { id }
          writtenBy { id }
        }
      }
    }
  }
  ```

---
### Fehlerbehandlung

* Zwei Arten:
  * Ein Feld gibt ein "fachliches" Fehler-Objekt zur√ºck (wie gesehen, z.B. `AddStoryFailed`)
  * Nicht behandelte (technische) Fehler werden √ºber das `errors`-Objekt an den Client geschickt
    * (trotzdem HTTP Status Code 200!)
* Das `errors`-Feld ist nicht genau spezifiziert und dessen Inhalt kann auch nicht im Schema beschrieben werden
* Deswegen sollte es nur f√ºr Ausnahmen verwendet werden, z.B. wenn der Query gar nicht ausgef√ºhrt werden kann, zum Beispiel, weil der Query ung√ºltig ist:
* ```json
  {
    "data": {},
    "errors": [
      {
        "message": "Cannot query field 'cmment' on type 'AddCommentSuccessPayload'.",
        "locations": [ { "line": 4, "column": 7 }
        ],
        "extensions": {
          "code": "GRAPHQL_VALIDATION_FAILED",
        }
      }
    ]
  }
  ```
---

### GraphQLErrors

* Neben dem Fehler (`message`) und der Angabe, bei welchem Feld im Query ein Fehler (`locations`) aufgetreten ist, gibt es ein `extensions`-Feld, das von GraphQL Servern
bef√ºllt werden kann.
* Apollo sendet darin einen `code` und ggf. den Stacktracke
* Das `extensions`-Feld kannst Du selbst setzen, in dem du einen `GraphQLError` in deinem Resolver wirfst.
  * Der `GraphQLError` erwartet im Konstruktor die Fehlermeldung und ggf. ein eigenes `extensions`-Objekt:
  * ```javascript
      throw new GraphQLError("Please log in", {
        extensions: {
          code: "INVALID_CREDENTIALS",
          requestId: "4129374981234"
        },
      });
      ```
  * Ergebnis:      
  * ```json
    {
      "errors": [
        {
          "message": "Please log in",
          "locations": [ { "line": 4, "column": 7 } ],
          "extensions": {
            code: "INVALID_CREDENTIALS",
            requestId: "4129374981234"
          }
        }
      ]
    }
    ```      

---
## Der GraphQL Context
---
### Der GraphQL Context

* Vor jeder Ausf√ºhrung eines GraphQL Requests vom Client kannst Du ein Context-Objekt erzeugen
* Das Context-Objekt ist ein regul√§res JavaScript-Objekt, das Du nach deinen Anforderungen bef√ºllen kannst
* Das Context-Objekt wird jeder Resolver-Funktion √ºbergebeen, die im Zuge des Requests aufgerufen wird.
* Typische Verwendung zum Beispiel zum √úbergeben des angemeldeten Benutzers oder auch Zugriff auf Daten-Quellen (z.B. DB Verbindung)

---

### Der GraphQL Context

* <!-- .element: class="demo" --> <code>X-Authorization</code> aus Request-Header lesen
* <!-- .element: class="demo" --> Im <code>ping</code>-Resolver auslesen

---

### Der GraphQL Context
<!-- .slide: id="graphql-context" -->


* Deine Funktion zum Erzeugen des Context-Objektes wird von Apollo vor jedem Request ausgef√ºhrt
* Der `context`-Funktion wird ein `config`-Objekt √ºbergeben. Wie das genau aussieht, h√§ngt von der Server-Konfiguration und den verwendeten Plug-ins ab
  * In der Regel hast Du aber zumindest das Express Request (`req`) und Response (`res`) Objekt darin
* Die Funktion muss ein Promise mit deinem Context-Objekt aufrufen
* ```javascript
  async function createPublyContext(config) {
    const userIdFromHttpHeader = config.req.get("X-Authorization") || null;

    // In "echter" Anwendung w√§re die User-Id ein Token
    // das wir hier vielleicht auch noch validieren w√ºrden...

    const context = {
      userId: userIdFromHttpHeader
    };

    return context;
  }
  ```
---
### Der GraphQL Context
* Die Funktion kannst Du entweder direkt am `ApolloServer` oder in der `expressMiddleware` angeben:

* ```javascript
  const app = express();
  const server = new ApolloServer({ /* ... */ });
  // ...

  app.use(
    "/graphql",
    cors(), json(),
    expressMiddleware(server, { context: createPublyContext })
  );
  ```  
* In unserer Beispiel-Anwendung geben wir die `context`-Funktion bei der `expressMiddleware` an, weil wir sp√§ter auch den Apollo Cache ben√∂tigen, auf den wir
  nur dort Zugriff haben. Ansonsten ginge auch:
* ```javascript
  const app = express();
  const server = new ApolloServer({ 
    // ...
    context: createPublyContext
  });
  // ...
  ```  
---
### √úbung: GraphQL Context

* <!-- .element: class="very-small" -->  
* **Verwende den GraphQL Context, um die userId an die Resolver zu √ºbergeben. Stelle im `addComment`-Resolver sicher, dass die `userId` gesetzt ist**
* Erzeuge in `start-graphql-server.ts` eine neue Funktion `createPublyContext`, die den Kontext erzeugt
* Die Funktion erwartet einen Parameter (`config`), der den HTTP Request und Response enth√§lt.
* Die Funktion soll ein Objekt zur√ºckliefern, das einen Eintrag enth√§lt `userId`:
  * Das ist entweder der Wert, der im HTTP-Header `X-Authorization` steht
  * oder `null`, falls der Request keinen solchen Header hat.
* F√ºge die Funktion als `context`-Eigenschaft dem zweiten Parameter von `expressMiddleware` hinzu
  * `expressMiddleware(server, { context: createPublyContext }))`  
* Im Resolver f√ºr `addComment` liest Du die `userId` aus.
  * Wenn die userId gesetzt ist, soll diese userId f√ºr den Aufruf von `publyDomainservice.addComment` verwendet werden.
  * Wenn keine `userId` gesetzt, einen GraphQL-Fehler erzeugen, so dass das `errors`-Objekt in der Antwort gef√ºllt wird (mit Fehlercode `NOT_LOGGED_IN`) 
* Den Header kannst Du zum Testen im `Headers`-Tab in der Apollo Sandbox setzen. Beispiel User-Id: `U3`.
  * <img src="images/auth-header.png" style="height:200px"/>
* Eine L√∂sung findest Du in `steps/04-context`  

---

## Daten aus anderen Systemen integrieren
<!-- .slide: id="externe-systeme-integrieren" -->
---

### Daten-Quellen

* Weder die GraphQL Spezifikation noch Apollo machen eine Aussage/stellen eine Anforderung, wo die Daten herkommen m√ºssen
* Wir k√∂nnen beliebige Datenquellen (DB, REST APIs, andere GraphQL APIs) in unseren Resolvern verwenden, um die ben√∂tigten Daten zu ermitteln
* Ihr k√∂nnt also einfach Eure Lieblingslibraries benutzen, die ihr ohnehin schon f√ºr den Zugriff auf Datenbank etc. benutzt

* Aber es gibt ein paar Klippen beim Zugriff auf externe Systeme!
* Performance üò±

---

### Caching

* Wir k√∂nnen Felder im Schema mit der Direktive `cacheControl` markieren
* Damit k√∂nnen wir steuern, wie lange ein Feld "g√ºltig" ist
  * Apollo f√ºgt dann einen `Cache-Control`-Header in Eure Antwort ein
  * Mit dem `responseCachePlugin` kann die Antwort auch im Server gecached werden
    * Der entsprechende Resolver wird dann nicht aufgerufen, sondern der Wert wird aus dem Cache geliefert
* Wenn mehrere Felder in einem Query abgefragt sind, die im Schema mit `cacheControl` als cachebar gekennzeichnet sind,
entscheidet die k√ºrzeste Cache-Dauer

* <!-- .element: class="demo" --> Cache-Control am ping-Feld mit Zeitstempel Datum
* <!-- .element: class="demo" --> HTTP Header
* <!-- .element: class="demo" --> responseCachePlugin (@apollo/server-plugin-response-cache)

---
### Laufzeitverhalten
<!-- .slide: class="left" -->
* Architektur der Anwendung: User kommen aus einem Microservice 
* Was passiert bei diesem Query?
* ```graphql
  query {
    allStories {   # Story
      writtenBy {  # Member
        user {     # User
          id fullname
        }
      }
    }
  }
  ```
* ```javascript
  const resolvers = {
    Query: { 
      allStories() { return publyDomainService.findAllStories() }
    },
    Member: {
      user(member) {
        // HTTP Request zu Microservice
        return userRestService.getUserForId(member.user_id)
      }
    }
  }
  ```
* *1+n-Problem üò±*  
---
### Laufzeitverhalten
<!-- .slide: class="left" -->
* *1+n-Problem üò±*  
* ```javascript
  const resolvers = {
    Query: { 
      allStories() { return publyDomainService.findAllStories() } // EIN Datenbankzugriff (liefert n Stories)
    },
    Member: {
      user(member) {
        return userRestService.getUserForId(member.user_id) // n REST-Aufrufe (1x pro Story-Member)
      }
    }
  }
  ```

---
### Apollo RESTDataSource

* `RESTDataSource` kann f√ºr den Zugriff auf externe Systeme per REST API verwendet werden
* Kann Antworten cachen
* Gab bis Apollo Server v3 [weitere DataSource-Implementierungen](https://www.apollographql.com/docs/apollo-server/v3/data/data-sources), u.a. f√ºr SQL. Scheinen in v4 entfernt worden zu sein.
* <!-- .element: class="demo" --> Beispiel: DataSource f√ºr UserService
* <!-- .element: class="demo" --> Beispiel: Requests werden gecached
* <!-- .element: class="demo" --> Beispiel: Caching der Ergebnisse mit HTTP Header

---

### RESTDataSource

* Abstrakte Oberklasse im Package `@apollo/datasource-rest`
* Property `baseURL` setzen
* An der Klasse sind Hilfsfunktionen zum Ausf√ºhren von HTTP Requests vorhanden
  * `this.get`, `this.post`
* Eigene abgeleitete Klasse anlegen und mit fachlichen Funktionen erg√§nzen
* ```javascript
  import { RESTDataSource } from "@apollo/datasource-rest";

  export default class UserServiceDataSource extends RESTDataSource {
    baseURL = "http://localhost:4010/";

    getUser(userId) {
      return this.get(this.baseURL + "users/" + userId);
    }
  }
  ```
* In der Regel werden die DataSources √ºber den Context an die Resolver √ºbergeben
* ```javascript
  async function createPublyContext(cache) {
    // ...
    const userServiceDataSource = new UserServiceDataSource();

    return {
      userId,
      datasources: {
        userServiceDataSource,
      },
    };
  }
  ```

---
### RESTDataSource: Verhalten anpassen

* Per Default wird der HTTP Request an die gegebenene URL gesendet
* Tritt dabei ein Fehler auf (technisch oder HTTP !== 2xx), wird ein Fehler geworfen
* Mit `willSendRequest` bzw. `didReceiveResponse` kann das Verhalten angepasst werden
  * Zum Beispiel setzen von HTTP Headern vor dem Absenden
  * Oder abweichende Fehlerbehandlung
* ```javascript
  export default class UserServiceDataSource extends RESTDataSource {
    // ...

    willSendRequest(opts) {
      opts.headers['X-Authorization'] = "mytoken"
    }

    didReceiveResponse(response, _request) {

      if (response.status === 404) {
        return Promise.resolve(null);
      }

      return super.didReceiveResponse(response, _request);
    }
  }
  ```  

---
### RESTDataSource: Request Caching

* Die Ergebnisse eines GET-Requests werden per Default in der DataSource-Instanz gecached
  * Requests mit identischer URL gelten als gleich, die URL wird per Default als Cache-Key verwendet
  * Abschalten mit `memoizeGetRequests = false`
  * Da die Instanz an den Lebenszyklus eines GraphQL Queries gebunden ist, gilt der Cache nur f√ºr einen Query
---
### RESTDataSource: Response Caching

* Wenn der angefragte Service einen `Cache-Control` HTTP-Header zur√ºckliefert, wird das Ergebnis ebenfalls gecacht
  * So lange, bis es gem√§√ü des Headers g√ºltig ist
* Dazu muss der Cache der Apollo Server-Instanz verwendet werden
  * Dieser ist dann auch Query-√ºbergreifend (und auch Client-√ºbergreifend) g√ºltig
  * Es gibt mehrere Implementierungen, per Default In-Memory (LRU)
* Die verwendete Cache-Instanz kann √ºber die laufende Server-Instanz abgefragt werden (`server.cache`) und an
  den Konstruktor der DataSource √ºbergeben werden
* ```javascript
  const server = new ApolloServer({ /* ... */ });
  //...

  await server.start();
  // ...

  const userServiceDataSource = new UserServiceDataSource(
    {cache}
  ));
  ```

---
### √úbung: RESTDataSource

* **Implementiere eine RESTDataSource, die die User aus unserem remote UserService liest**
* Vorbereitung: Starte den UserService (`pnpm start` in `app/userservice`)
* Schritt 1: Lege die Klasse `UserServiceDataSource` an
  * Die URL zum Abfragen eines Users lautet: http://localhost:4010/users/USERID
  * Die Klasse soll eine Methode bekommen, mit der ein User an Hand seiner ID abgefragt werden kann.
  * Erweiter die `createPublyContext`-Funktion, erzeuge dort eine Instanz der UserServiceDataSource.
  * F√ºge die Instanz dem GraphQL Context hinzu.
* Schritt 2: Implementiere den Resolver f√ºr `Member.user`
  * Das erweiterte Schema findest Du in `material/member-schema.graphql`. Kopiere es an dein bestehendes Schema.
  * In `resolvers` implementiere den Resolver f√ºr `Member.user`
  * Das Parent-Objekt `member` hat ein Feld `userId`. Mit diesem Wert musst du deine UserServiceDataSource aufrufen.
* Der Query auf der folgenden Seite sollte dann funktionieren und einen User zur√ºckliefern.

---
### √úbung: RESTDataSource

* Wenn die UserServiceDataSource korrekt funktioniert, sollte dieser Query funktionieren:
* ```graphql
  query {
    story(storyId: "1") {
      title
      writtenBy {
        user { id fullname login }
      }
  
      comments {
        writtenBy {
          user { id fullname login }
        }
      }
    }
  }
  ```
* Sowohl der `user` in der Story als auch die User in den Kommentaren sollten zur√ºckgeliefert werden.  


---
## Testen
<!-- .slide: id="testen" -->

---

### Optionen

* Resolver direkt testen (Unit-Test?)
* Integration-Tests (GraphQL Queries ausf√ºhren)
* End2End-Tests (GraphQL Queries per HTTP ausf√ºhren)

---
### Beispiel Resolver Test
<!-- .slide: class="left" -->
* Mit Jest Testframework
* ```javascript
  it("ping resolver should work", () => {
    expect(resolvers.Query.ping({}, {}, {}, {})).toBe("hello");
  });
  ```

---
### Beispiel Integrationtest

* Der ApolloServer wird dabei mit den regul√§ren Resolvern und dem echten Schema (oder Teilen davon) erzeugt
* Mit `executeOperation` am `ApolloServer` kann direkt ein Query ausgef√ºhrt werden
* Die Funktion liefert ein `GraphQLResponse` Objekt zur√ºck
* Dieses Objekt hat ein `body`-Property:
  * das ist entweder ein einfaches Ergebnis (Normalfall)
  * oder ein "incremental" Result (z.B. f√ºr Queries mit `@defer`). Das ist noch experimentell.
* ```javascript
  const typeDefs = /* ... */;
  const resolvers = /* ... */;

  const server = new ApolloServer({
    typeDefs,
    resolvers,
  });

  it("ping should return hello", async () => {

    const result = await server.executeOperation({
      query:"query { ping }"
    });

    expect(result.body.singleResult.data?.ping).toBe(
      "hello"
    );
  });
  ```
---
### Tipp f√ºr JetBrains IDEs

* Wenn ihr IntelliJ oder Webstorm verwendet...
* ...k√∂nnt ihr das [GraphQL Plugin](https://plugins.jetbrains.com/plugin/8097-graphql) installieren
* dann k√∂nnt ihr im Source-Code mit `// language=GraphQL` markieren, wenn die n√§chste Zeile GraphQL Code enth√§lt
* dann bekommt ihr Syntax Highlighting und bei Konfiguration des Schemas auch Code Completion
* ```javascript
  it("should return single story by id", async () => {
    const result = await server.executeOperation({

      // language=GraphQL
      query: "query GetStory($storyId: ID!) { story(storyId: $storyId) { title } }",
    });
  });
  ```
---
### Beispiel Integrationtest

* Neben dem `query` k√∂nnen beim Ausf√ºhren auch Variablen √ºbergeben
* Dazu das `variables`-Property verwenden
* ```javascript
  const server = /* ... */;

  it("should return single story by id", async () => {
    const result = await server.executeOperation({

      query:
        "query GetStory($storyId: ID!) { story(storyId: $storyId) { title } }",

      variables: 
        { storyId: "1" },
    });

    expect(result.body.singleResult.data?.story.title).toBe(
      "Authentication and Access Control with Relay"
    );
  });
  ```
---
### Beispiel Integrationtest: Context

* Die `executeOperation`-Funktion kann zwei Argumente entgegen nehmen:
  * `request` (wie gesehen Objekt mit `query` und evtl. `variables`)
  * `options`
* √úber `options.contextValue` kann ein Context-Objekt f√ºr einen Request gesetzt werden  
  * Je mehr Informationen in den Resolvern √ºber das Context-Objekt abgefragt werden, desto einfacher das Mocken an dieser Stelle...

* ```javascript
  it("should add new comment with user id from context", async () => {
    const result = await server.executeOperation({
        query: `mutation {
          addComment(input: { storyId: "3", content: "New Comment!"})	{
            ...on AddCommentSuccessPayload {
                newComment { id }
            }
          }
        }`
      },
      {
        contextValue: { userId: "U3" },
      }
    );

    expect(result.body.singleResult.errors).toBeFalsy();
    expect(result.body.singleResult.data?.addComment.newComment.id).toBe("15");
  });
  ```

---
### √úbung: Tests

* **Schreibe ein oder zwei einfache Tests f√ºr Queries**
* Die Datei `src/graphql/publy-api.test.ts` ist bereits vorbereitet
* Du musst dort den `ApolloServer` erzeugen und `typeDefs` und `resolvers` √ºbergeben
* Schreibe dann ein oder zwei Tests um (einfache) Queries zu testen
* Du kannst die Tests mit `pnpm test` oder `pnpm test --watch` ausf√ºhren
* Hinweis: 
  * Da das eine TypeScript-Datei ist, werden eigentlichen Typen erwartet. Der einfachheithalber markiere `result` einfach als `any`
    * `const result: any = await server....`
  * Um Fehler zu sehen, am besten das Ergebnis mit `JSON.stringify(result)` auf der Konsole ausgeben
* L√∂sung in `steps/06-tests`
---
## TypeScript
<!-- .slide: id="typescript" -->

* Typen generieren
* Typen f√ºr Resolver
* Typen f√ºr Context
* Typen im Client und end2end-Typisierung

---


  </textarea
          >
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit GraphQL!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            <a
              href="https://www.xing.com/profile/Nils_Hartmann2/cv"
              target="_blank"
              >Xing</a
            >
          </p>

          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>
    <script src="revealjs/reveal.js/dist/reveal.js"></script>
    <script src="revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="revealjs/config.js"></script>
  </body>
</html>
